[DEFNAME administrative_constants]
SM_RED=028
SM_GREEN=044
SM_BLUE=04
SM_YELLOW=036
SM_ORANGE=02c
SND_GLASS={{03e 041} 1 {038d 0390} 1}
SND_THUNDER={05CE 1 028 1 029 1 0206 1}

i_cabeca_placa_cobre        i_elmo_placa_cobre
i_cabeca_placa_bronze       i_elmo_placa_bronze
i_cabeca_placa              i_elmo_placa
i_cabeca_placa_prata        i_elmo_placa_prata
i_cabeca_placa_ouro         i_elmo_placa_ouro
i_cabeca_placa_mithril      i_elmo_placa_mithril
i_cabeca_placa_ebano        i_elmo_placa_ebano
i_cabeca_placa_rubridium    i_elmo_placa_rubridium
i_cabeca_placa_obsidiana    i_elmo_placa_obsidiana
i_cabeca_placa_eldasthar    i_elmo_placa_eldasthar

i_cabeca_segmentada_cobre       i_elmo_semi_cobre
i_cabeca_segmentada_bronze      i_elmo_semi_bronze
i_cabeca_segmentada             i_elmo_semi
i_cabeca_segmentada_prata       i_elmo_semi_prata
i_cabeca_segmentada_ouro        i_elmo_semi_ouro
i_cabeca_segmentada_mithril     i_elmo_semi_mithril
i_cabeca_segmentada_ebano       i_elmo_semi_ebano
i_cabeca_segmentada_rubridium   i_elmo_semi_rubridium
i_cabeca_segmentada_obsidiana   i_elmo_semi_obsidiana
i_cabeca_segmentada_eldasthar   i_elmo_semi_eldasthar
i_picareta                      i_pickaxe
i_pickaxe_exp                   i_picareta_exp
i_osso                          i_r_osso

spellflag_eval_boosts 0400000           //Spellflag. Eval int é 50% do EFFECT

[PLEVEL 6]
f_connectDB
worldrespawn

//*****************************************************************************
//*****************************************************************************
// FUNCOES
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
// f_oncommand( )
//*****************************************************************************
[FUNCTION f_oncommand]
if strmatch("<args>","xresurrect")
    src.sysmessagered Utilize xress
    return 1
elif (strmatch(hungry,<args>))
    comida
    return 1
elif (strmatch(cast*,<args>))
    if (!<src.IsGM>)
     src.sysmessagered Comando bloquado! Risco de Exploit. Sua conta foi marcada.
     src.targ.tag0.fconf=<src.targ.tag0.fconf>+1
     serv.allclients broadstaff Exploit! Tentou usar comando .cast,"<src.account>"
     serv.log [Magia] EXPLOIT:: <src.tag.name> [<src.account] tentou usar comando .cast
     event_note <src.uid>,Exploit! Tentou usar comando .cast
     return 1
    endif
endif

//*****************************************************************************
// f_connectDB( )
//*****************************************************************************
[FUNCTION f_connectDB]
DB.CONNECT
if (<DB.CONNECTED>)
//    SERV.log MySQL debug: MySQL successfully connected!
else
    SERV.log MySQL debug: MySQL not connected!
endif

//*****************************************************************************
// f_onchar_delete
//*****************************************************************************
// This function is called before client is going to delete a character.
// SRC  --> char being deleted
// ARGO --> the client deleting the character
// RETURN
//    0 --> normal action (delete char)
//    1 --> denyes deletion
[FUNCTION f_onchar_delete]
if ( <DB.connected> )
    //remove char itens on deletion
    DB.EXECUTE "DELETE FROM vendorItems WHERE idPlayer=<eval <SRC>>"
    //clear spells from DB
    //src.mage_wipeSpells
    //prune house system
    //src.CustomH_WipeUser
endif

//*****************************************************************************
// f_sendMessage( uidPlayer, message, msgColor )
//*****************************************************************************
//envia mensagem para um player online. se estiver offline a mensagem é armazenada no banco
//e entregue no proximo login.
//
// ARGV[0] --> UID destino
// ARGV[1] --> mensagem
// ARGV[2] --> cor (SM_RED,SM_GREEN...etc)
[FUNCTION f_sendMessage]
    
//save OBJ ref.
    LOCAL.obj=<OBJ>
    
    OBJ=<argv[0]>
    if ( <OBJ.isonline> )
        OBJ.sysmessage @<argv[2]> <argv[1]>
    else
        if ( <DB.connected> )
            DB.EXECUTE INSERT INTO messageBox SET timestamp=NOW(), message="<argv[1]>", status='Pending', triggerUid=<eval <SRC>>, toUid=<eval <argv[0]>>, color=<eval <argv[2]>>
        endif
    endif
    
    OBJ=<LOCAL.obj>
    
//*****************************************************************************
// f_deliverPendingMessages( )
//*****************************************************************************
//chame essa funcao no login para enviar as mensagens pendentes ao player.  
//SRC é o player fazendo login
[FUNCTION f_deliverPendingMessages]
if ( <DB.connected> )
    DB.QUERY "SELECT message,color FROM messageBox WHERE status='Pending' AND toUid=<eval <SRC.uid>>"
    if (<DB.ROW.NUMROWS> > 0)
        for R 0 <eval <DB.ROW.NUMROWS>-1>
            SRC.sysmessage @<DB.ROW.<eval <LOCAL.R>>.color> <DB.ROW.<eval <LOCAL.R>>.message>
        end
        DB.EXECUTE "UPDATE messageBox SET status='Sent' WHERE toUid=<eval <SRC.uid>>"
    endif
endif
    

//*****************************************************************************
// f_isWeapon( item )
//*****************************************************************************
//retorna 1 se o argumento for uma arma
[FUNCTION f_isWeapon]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_weapon_axe )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_smith )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_sharp )
        return 1
    elif ( <LOCAL.type>==t_weapon_sword )
        return 1
    elif ( <LOCAL.type>==t_weapon_fence )
        return 1
    elif ( <LOCAL.type>==t_weapon_bow )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_staff )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_crook )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_pick )
        return 1
    elif ( <LOCAL.type>==t_weapon_arrow )
        return 1
    elif ( <LOCAL.type>==t_weapon_bolt )
        return 1
    elif ( <LOCAL.type>==t_weapon_xbow )
        return 1
    elif ( <LOCAL.type>==t_string )
        return 1
    elif ( <LOCAL.type>==t_weapon_ammo )
        return 1        
    elif ( <LOCAL.type>==t_ponta_flecha )
        return 1        
    else
        return 0
    endif

//*****************************************************************************
// f_isWeaponTool( item )
//*****************************************************************************
//retorna 1 se o argumento for uma arma
[FUNCTION f_isWeaponTool]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_weapon_mace_smith )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_staff )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_crook )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_pick )
        return 1
    elif ( <uid.<argn>.id>==0F51 ) || ( <uid.<argn>.id>==0EC4 ) || ( <uid.<argn>.id>==013F6 ) || ( <uid.<argn>.id>==0EC2 )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isArmor( item )
//*****************************************************************************
//retorna 1 se o argumento for uma armadura (ou escudo)
[FUNCTION f_isArmor]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_armor )
        return 1
    elif ( <LOCAL.type>==t_armor_leather )
        return 1
    elif ( <LOCAL.type>==t_shield )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isRegsOrMagic( item )
//*****************************************************************************
//retorna 1 se o argumento for uma reagente ou magico
[FUNCTION f_isRegsOrMagic]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_wand )
        return 1
    elif ( <LOCAL.type>==t_potion )
        return 1
    elif ( <LOCAL.type>==t_potion_empty )
        return 1
    elif ( <LOCAL.type>==t_reagente )
        return 1
    elif ( <LOCAL.type>==t_almofariz )
        return 1
    elif ( <LOCAL.type>==t_espiriteira )
        return 1
    elif ( <LOCAL.type>==t_misturador )
        return 1
    elif ( <LOCAL.type>==t_tubo )
        return 1
    elif ( <LOCAL.type>==t_gem_stoned )
        return 1
    elif ( <LOCAL.type>==t_gem )
        return 1
    elif ( <LOCAL.type>==t_scroll )
        return 1
    else
        return 0
    endif
//*****************************************************************************
// f_isFood( item )
//*****************************************************************************
//retorna 1 se o argumento for um alimento/comestivel
[FUNCTION f_isFood]
LOCAL.type = <uid.<argn>.type>
if ( <LOCAL.type>==t_food )
return 1
elif ( <LOCAL.type>==t_food_raw )
return 1
elif ( <LOCAL.type>==t_fish )
return 1
elif ( <LOCAL.type>==t_fruit )
return 1
elif ( <LOCAL.type>==t_meat_raw )
return 1
elif ( <LOCAL.type>==t_recipient )
return 1
elif ( <LOCAL.type>==t_crops )
return 1
elif ( <LOCAL.type>==t_foliage )
return 1
else
return 0
endif

//*****************************************************************************
// f_isMisc( item )
//*****************************************************************************
//retorna 1 se o argumento for ferramenta, movel, etc
[FUNCTION f_isMisc]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_clock )
        return 1
    elif ( <LOCAL.type>==t_termometro )
        return 1
    elif ( <LOCAL.type>==t_musical )
        return 1
    elif ( <LOCAL.type>==t_recipe )
        return 1
    elif ( <LOCAL.type>==t_recipe_book )
        return 1
    elif ( <LOCAL.type>==t_carpentry )
        return 1
    elif ( <LOCAL.type>==t_chair )
        return 1
    elif ( <LOCAL.type>==t_sextant )
        return 1
    elif ( <LOCAL.type>==t_table )
        return 1
    elif ( <LOCAL.type>==t_fish_pole )
        return 1
    elif ( <LOCAL.type>==t_shaft )
        return 1
    elif ( <LOCAL.type>==t_tinker_tools )
        return 1
    elif ( <LOCAL.type>==t_carpentry_tool )
        return 1
    elif ( <LOCAL.type>==t_cooking_tool )
        return 1
    elif ( <LOCAL.type>==t_bancada )
        return 1
    elif ( <LOCAL.type>==t_light_out )
        return 1
    elif ( <LOCAL.type>==t_fish_pole )
        return 1
    elif ( <LOCAL.type>==t_oleo )
        return 1
    elif ( <LOCAL.type>==t_book )
        return 1
    elif ( <LOCAL.type>==t_map_blank )
        return 1
    elif ( <LOCAL.type>==t_book_scroll )
        return 1
    elif ( <LOCAL.type>==t_sand )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_preitem_bowcraft )
        return 1
    elif ( <LOCAL.type>==t_preitem_carpentry )
        return 1
    elif ( <LOCAL.type>==t_tinker_parts )
        return 1
    elif ( <LOCAL.type>==t_buy_misc )
        return 1
    elif ( <LOCAL.type>==t_arame )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_luz_oleo )
        return 1        
    elif ( <LOCAL.type>==t_container )
        return 1   
    elif ( <LOCAL.type>==t_fechadura )
        return 1 
    elif ( <LOCAL.type>==t_gem_stoned )
        return 1
    elif ( <LOCAL.type>==t_crafting_tool )  //Venda de ferramenta de artesão, de carpinteiro, panela, frigideira, assadeira, tigela para massa
        return 1
    elif ( <LOCAL.type>==t_lockpick ) // permite vender lockpick
        return 1
    elif ( <LOCAL.type>==t_cachimbo ) // permite vender cachimbo
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isWearable( item )
//*****************************************************************************
//retorna 1 se o argumento for roupas, joias, etc
[FUNCTION f_isWearable]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_clothing )
        return 1
    elif ( <LOCAL.type>==t_cloth )
        return 1
    elif ( <LOCAL.type>==t_tailoring )
        return 1
    elif ( <LOCAL.type>==t_thread )
        return 1
    elif ( <LOCAL.type>==t_yarn )
        return 1
    elif ( <LOCAL.type>==t_jewelry )
        return 1
    elif ( <LOCAL.type>==t_bandagem )
        return 1
    elif ( <LOCAL.type>==t_fibra )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isRaw( item )
//*****************************************************************************
//retorna 1 se o argumento for materia prima
[FUNCTION f_isRaw]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_log )
        return 1
    elif ( <LOCAL.type>==t_ore )
        return 1
    elif ( <LOCAL.type>==t_gem )
        return 1
    elif ( <LOCAL.type>==t_gem_stoned )
        return 1
    elif ( <LOCAL.type>==t_ingot )
        return 1
    elif ( <LOCAL.type>==t_seed )
        return 1
    elif ( <LOCAL.type>==t_leather )
        return 1
    elif ( <LOCAL.type>==t_loom )
        return 1
    elif ( <LOCAL.type>==t_feather )
        return 1
    elif ( <LOCAL.type>==t_wool )
        return 1
    elif ( <LOCAL.type>==t_fur )
        return 1
    elif ( <LOCAL.type>==t_thread )
        return 1
    elif ( <LOCAL.type>==t_yarn )
        return 1
    elif ( <LOCAL.type>==t_cotton )
        return 1
    elif ( <LOCAL.type>==t_preitem_bowcraft )
        return 1
    elif ( <LOCAL.type>==t_preitem_carpentry )
        return 1
    elif ( <LOCAL.type>==t_arame )
        return 1
    elif ( <LOCAL.type>==t_buy_raw )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_hide )
        return 1
    elif ( <LOCAL.type>==t_grain )
        return 1
    elif ( <LOCAL.type>==t_mring )
        return 1
    elif ( <LOCAL.type>==t_plate )
        return 1
    elif ( <LOCAL.type>==t_fibra )
        return 1
    elif ( <LOCAL.type>==t_fumo )  // permite vender fumo
        return 1
    elif ( <LOCAL.type>==t_catalisador )   //para vender carvao
        return 1
    elif ( <LOCAL.type>==t_kindling )   //para gravetos
        return 1
    else
        return 0
    endif

//*****************************************************************************
// isLight
//*****************************************************************************
//retorna 1 se DEFAULT for luz (e aceso)
[FUNCTION isLight]
if <type>==t_light_lit
    return 1
elif (<type>==t_luz_oleo) && (<timer>>0)
    return 1
endif
return 0

//*****************************************************************************
// IsItemdef
//*****************************************************************************
//retorna 1 se <args> é um ITEMDEF válido
[FUNCTION IsItemdef]
return <eval (0<def.<args>>&09c000000)==09c000000>

//*****************************************************************************
// IsChardef
//*****************************************************************************
//retorna 1 se <args> é um CHARDEF válido
[FUNCTION IsChardef]
return <eval ((0<def.<args>>^08c000000) < 010000000) && ((0<def.<args>>&08c000000)==08c000000)>

//*****************************************************************************
// IsAreadef
//*****************************************************************************
//retorna 1 se <args> é uma AREADEF válida
[FUNCTION IsAreadef]
return <eval (0<def.<args>>&086000000)==086000000>

//*****************************************************************************
// IsFaceVisible
//*****************************************************************************
//retorna 1 se DEFAULT pode ser reconhecido
[FUNCTION IsFaceVisible]
if <restest i_capuz>
    return 0
elif <findlayer.layer_helm>
    return 0
endif

return 1

//*****************************************************************************
// cont_Weight
//*****************************************************************************
//Retorna o peso do conteúdo do container, sem contar o peso dele mesmo.
[FUNCTION cont_Weight]
if (STRMATCH(*.*,<serv.itemdef.<defname>.weight>))
    return <eval <weight>-<serv.itemdef.<defname>.weight>>
else
    return <eval <weight>-(<serv.itemdef.<defname>.weight>*10)>
endif

//*****************************************************************************
// cont_MaxWeight
//*****************************************************************************
//Retorna o peso máximo do container
[FUNCTION cont_MaxWeight]
if (!<IsEmpty <TAG.OVERRIDE.MAXWEIGHT>>)
    return <TAG.OVERRIDE.MAXWEIGHT>
elif (!<TDATA4>)
    return 0
else
    return <TDATA4>
endif

//*****************************************************************************
// cont_checkWeight( weight )
//*****************************************************************************
//Verifica se cabe o peso especificado no container. Retorna o peso total se não cabe.
//DEFAULT deve ser o container
[FUNCTION cont_checkWeight]
if (!<cont_MaxWeight>)
    return 0
else    
    LOCAL.n=<eval <cont_Weight>+<argn>>
//    serv.log [CONT] LOCAL.n=<fval <local.n>> :: Max=<fval <cont_MaxWeight>>
    if ( <LOCAL.n> > <cont_MaxWeight> )
        if !(<src.isgm>)
            return <local.n>
        endif
    endif
endif
return 0

//*****************************************************************************
// wipeObject <DEFNAME> Remove todos os itens <DEFNAME> do world.
//*****************************************************************************
[FUNCTION wipeObject]
IF !(<ARGN>)
 IF (<ISEMPTY <DEF.<ARGS>>>)
  SYSMESSAGE <args> nao existe.
  RETURN 0
 endif
endif
IF !(<ISEMPTY <ARGS>>)
 IF !(<SERV.ITEMDEF.<ARGS>>) && !(<SERV.CHARDEF.<ARGS>>)
  SYSMESSAGE <ARGS> nao eh um item nem criatura.
  RETURN 0
 endif
 FORINSTANCES <argv[0]>
  LOCAL.wipe=<local.wipe>+1
  remove
 ENDFOR
 if (<IsGM>)
  sysmessageorange Removidos <eval <LOCAL.wipe>> instancias de <SERV.ITEMDEF.<argv[0]>.NAME>
 endif
endif

//*****************************************************************************
// subsObject <DEFNAME>,<new.defname> Remove todos os itens <DEFNAME> do world e substitui por <new.defname>.
//*****************************************************************************
[FUNCTION subsObject]
IF !(<ISEMPTY <ARGV0>>)
 IF !(<SERV.ITEMDEF.<ARGV0>>) && !(<SERV.CHARDEF.<ARGV0>>)
  SYSMESSAGE <ARGV0> nao eh um item nem criatura.
  RETURN 0
 endif
endif
IF !(<ISEMPTY <ARGV1>>)
 IF !(<SERV.ITEMDEF.<ARGV1>>) && !(<SERV.CHARDEF.<ARGV1>>)
  SYSMESSAGE <ARGV1> nao eh um item nem criatura.
  RETURN 0
 endif
endif

FORINSTANCES <argv[0]>
 if (<IsItem>)
  newitem=<argv1>
  if (<cont>)
   new.cont=<cont>
  else
   new.p=<p>
  endif
  LOCAL.wipe=<local.wipe>+1
  remove
 elif (<IsChar>)
  if (<NPC>)
   newnpc <argv1>
   new.p=<p>
   LOCAL.wipe=<local.wipe>+1
   remove
  ENDIF
 ENDIF
ENDFOR
if (<IsGM>)
 sysmessageorange Removidos <eval <LOCAL.wipe>> instancias de <SERV.ITEMDEF.<argv[0]>.NAME>
endif


//*****************************************************************************
//  CRY Faz o char gritar de dor e animar (compatibilidade com 55i)
//*****************************************************************************

[FUNCTION cry]
//// anima
anim 20                     //Animação de @GetHit
bark 3

//*****************************************************************************
//  EFFECTSPELL <spell>,<skill_dif>,<UIDcaster>
//*****************************************************************************
//Retorna o EFFECT de uma magia de acordo com uma skill
//Se a spell tiver spellflag_resist, calcula o retorno para MagicResist do DEFAULT.
[FUNCTION EFFECTSPELL]
LOCAL.skill=<argn1>
LOCAL.min=<minimum <SERV.SPELL.<argv0>.EFFECT>>
LOCAL.eff=<maximum <SERV.SPELL.<argv0>.EFFECT>>

//Eavl Int entra na jogada?
if (<serv.spell.<argv0>.FLAGS>&spellflag_eval_boosts)
 if (0<argv2>)
  obj=<argv2>
  local.skill=<eval (<local.skill>/2)+(<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<obj.EvaluatingIntel>>/2)>
  obj.skill_gain skill_evalint
 endif
endif

//Resisting spells?
if !<isitem>
 if (<serv.spell.<argv0>.FLAGS>&spellflag_resist)
  if (<BELLTEST <MagicResistance>,<LOCAL.skill>>)
   sysmessageblue Voce resiste a magia.
   //Resistir totalmente?
   if (<BELLTEST <MagicResistance>,140.0>)   //Resistir totalmente
    LOCAL.min=0
    LOCAL.eff=0
    sfx 05C1
    emotered resistiu
   else                      //Resistir parcialmente
    LOCAL.eff=<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<eval 1010-<MagicResistance>>>
   endif
  endif
  skill_gain skill_magicresist
 endif
endif

local.err=<eval 100-<R0,<f_rangeValue 0,20,<argv1>>>>
LOCAL.eff=<f_rangeValue <LOCAL.min>, <LOCAL.eff>, <argv1>>
local.eff=<eval (<local.eff>*<local.err>)/100>
RETURN <eval <LOCAL.eff>>


//*****************************************************************************
//  DURATIONSPELL <spell>,<skill_dif>,<UIDcaster>
//*****************************************************************************
//Retorna o DURATION de uma magia de acordo com uma skill
//Se a spell tiver spellflag_resist, calcula o retorno para MagicResist do DEFAULT.
[FUNCTION DURATIONSPELL]
LOCAL.skill=<argn1>
LOCAL.min=<minimum <SERV.SPELL.<argv0>.DURATION>>
LOCAL.eff=<maximum <SERV.SPELL.<argv0>.DURATION>>

//Eavl Int entra na jogada?
if (<serv.spell.<argv0>.FLAGS>&spellflag_eval_boosts)
 if (0<argv2>)
  obj=<argv2>
  local.skill=<eval (<local.skill>/2)+(<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<obj.EvaluatingIntel>>/2)>
  obj.skill_gain skill_evalint
 endif
endif

//Resisting spells?
if !<isitem>
 if (<serv.spell.<argv0>.FLAGS>&spellflag_resist)
  if (<BELLTEST <MagicResistance>,<LOCAL.skill>>)
   //Resistir totalmente?
   sysmessageblue Voce resiste a magia.
   if (<BELLTEST <MagicResistance>,140.0>)   //Resistir totalmente
    LOCAL.min=0
    LOCAL.eff=0
    sfx 05C1
    emotered resistiu
   else                      //Resistir parcialmente
    LOCAL.eff=<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<eval 1010-<MagicResistance>>>
   endif
  endif
  skill_gain skill_magicresist
 endif
endif

local.err=<eval 100-<R0,<f_rangeValue 0,20,<argv1>>>>
LOCAL.eff=<f_rangeValue <LOCAL.min>, <LOCAL.eff>, <argv1>>
local.eff=<eval (<local.eff>*<local.err>)/100>

RETURN <eval <LOCAL.eff>>

//*****************************************************************************
//  DAMAGESPELL <spell>,<dam_type>,<skill>,<UIDcaster>
//*****************************************************************************
//Danifica conforme a magia <argv0> com tipo <argv1> como se tivesse magery <argv2> por <<argv3>.UID>
[FUNCTION damagespell]
LOCAL.dam=<EFFECTSPELL <argv0>, <argv2>, <argv3>>
DAMAGE <LOCAL.dam> <EVAL <argv1>> <argv3>                           //aplica o dano com o tipo modificado
RETURN <LOCAL.dam>

//*****************************************************************************
//  IsStonned
//*****************************************************************************
//Retorna se o char está stonnado ou não.
[FUNCTION IsStonned]
if (<restest 1 i_stonned>)
 RETURN 1
else
 RETURN 0
endif

//*****************************************************************************
//  Stonned <tempo>
//*****************************************************************************
//Petrifica um char por <tempo> segundos.
[FUNCTION Stonned]
if (<IsStonned>)
 RETURN 0
endif
serv.newitem i_stonned
new.timer=<argn>
equip <new.uid>
RETURN 1

[ITEMDEF i_stonned]
ID=020A5
NAME=Petrificado
TYPE=t_eq_script
LAYER=layer_special

on=@equip
cont.flags=<cont.flags>|040000
cont.update

on=@timer
cont.flags=<cont.flags>&~040000
cont.sysmessageblue Voce nao esta mais petrificado.
cont.update
remove
RETURN 1

//*****************************************************************************
// emotes
//*****************************************************************************
[FUNCTION emotegreen]
SAY @<DEF.SM_GREEN>,  *<args>*

[FUNCTION emotered]
SAY @<DEF.SM_RED>,  *<args>*

[FUNCTION emoteyellow]
SAY @<DEF.SM_YELLOW>,  *<args>*

[FUNCTION emoteblue]
SAY @<DEF.SM_BLUE>,  *<args>*

[FUNCTION emoteorange]
SAY @<DEF.SM_ORANGE>,  *<args>*

//*****************************************************************************
// sysmessage
//*****************************************************************************
[FUNCTION sysmessagered]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_RED>,3  <args>
endif

[FUNCTION sysmessageblue]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_BLUE>,3  <args> 
endif

[FUNCTION sysmessagegreen]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_GREEN>,3  <args> 
endif

[FUNCTION sysmessageyellow]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_YELLOW>,3  <args> 
endif

[FUNCTION sysmessageorange]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_ORANGE>,3  <args> 
endif

//*****************************************************************************
// Regen time
//*****************************************************************************

[FUNCTION HitsRegen]
//If <argn> is present, changes the time (in seconds) to earn a Hitpoint by regeneration and returns the old value.
//If not present return the time (in seconds) to earn a Hitpoint by regeneration.
IF (!<argn>)
 return <eval (<serv.regen0>/10)-<TAG0.OVERRIDE.Regen_0>>
endif
local.old=<eval (<serv.regen0>/10)-<TAG0.OVERRIDE.Regen_0>>
TAG.OVERRIDE.Regen_0=<eval (<serv.regen0>/10)-<argn>>
return <local.old>

[FUNCTION ManaRegen]
//If <argn> is present, changes the time (in seconds) to earn a Mana point by regeneration and returns the old value.
//If not present return the time (in seconds) to earn a Mana point by regeneration.
IF (!<argn>)
 return <eval (<serv.regen1>/10)-<TAG0.OVERRIDE.Regen_1>>
endif
local.old=<eval (<serv.regen1>/10)-<TAG0.OVERRIDE.Regen_1>>
TAG.OVERRIDE.Regen_1=<eval (<serv.regen1>/10)-<argn>>
return <local.old>

[FUNCTION StamRegen]
//If <argn> is present, changes the time (in seconds) to earn a Stam point by regeneration and returns the old value.
//If not present return the time (in seconds) to earn a Stam point by regeneration.
IF (!<argn>)
 return <eval (<serv.regen2>/10)-<TAG0.OVERRIDE.Regen_2>>
endif
local.old=<eval (<serv.regen2>/10)-<TAG0.OVERRIDE.Regen_2>>
TAG.OVERRIDE.Regen_2=<eval (<serv.regen2>/10)-<argn>>
return <local.old>


//*****************************************************************************
// decrement [amount]
//*****************************************************************************
[FUNCTION decrement]
if <argn>
    amount -= <argn>
else    
    amount -= 1
endif

if <amount> < 1
    remove
endif
update

//*****************************************************************************
// dconsume val key [,val key[,val key...]]
//*****************************************************************************
[FUNCTION dconsume]
for i 0 <eval <argv>-1>
 if (<isNum <strarg <argv[<local.i>]>>>)
  local.amt=<strarg <argv[<local.i>]>>
  local.item=<findid.<streat <argv[<local.i>]>>>
 else
  local.amt=1
  local.item=<findid.<argv[<local.i>]>>
 endif
 serv.log [DCONSUME] i:<uid.<local.item>.name> a:<local.amt> (<args>)
 uid.<local.item>.trigger @Consume,<DEF.TAT_AS_ARGN>,<local.amt>
 consume <local.amt>
endfor

//*****************************************************************************
// f_sendTooltip(title,text)
//*****************************************************************************
[FUNCTION f_sendTooltip]
src.addcliloc 1042971,<argv0>
src.addcliloc 1070722,<argv1>

//*****************************************************************************
// f_sendTooltipData(text)
//*****************************************************************************
[FUNCTION f_sendTooltipData]
src.addcliloc 1070722,<argv0>

//*****************************************************************************
// checkVersion([major],[lower],[minor])
//*****************************************************************************
[FUNCTION checkVersion]
if (!0<argv0>)
    return <f_checkVersion <explode .,<CLIENTVERSION>>>
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
    return 1
endif
return 0

//*****************************************************************************
// f_checkVersion(major,lower,minor)
//*****************************************************************************
[FUNCTION f_checkVersion]
if (!0<argv0>)
    serv.log Clientversion invalido: <CLIENTVERSION> -- <argv0>::<argv1>::<argv2>
    return 0
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
    return 1
endif
return 0

//*****************************************************************************
// f_spreadValue(value,error)
//*****************************************************************************
//dado um valor value, retorn um valor aleatorio V+-K, onde K vai de 0 a
//(V/2) (erro 100%)
//'error' deve ser passado entre 0 (retorna 'value') e Cm (atualmente 50)

//Formula e simplificavao:
//Vn=V*[1+(2*Er-Em)/(2*Cm)]
//Vn=V*[(2*Cm)+(2*Er)-Em)]/(2*Cm)
//Vn=V*[K-Em+(2*Er)]/k
//Vn - valor falso
//V  - valor real ('value')
//Cm - Maximo % de erro (0 a 100). Atualmente ajustado em 50.
//Em - Erro máximo ('error')
//Er - Erro random (0 a Em)
[FUNCTION f_spreadValue]
return <eval (<argv0>*((100-<argv1>)+(2*<R0,<argv1>>)))/100>

//*****************************************************************************
// f_rangeValue(min,max,skill)
//*****************************************************************************
//dado um valor value, retorn um valor de acordo com uma regra de tres
//composta entre <min> e <max> de acordo com <skill>
[FUNCTION f_RangeValue]
LOCAL.min=<argv0>
LOCAL.max=<argv1>
LOCAL.skill=<argv2>
LOCAL.max=<LOCAL.max>-<LOCAL.min>
LOCAL.max=((<LOCAL.max>*<LOCAL.skill>)/1000)+<LOCAL.min>
return <eval <LOCAL.max>>

//*****************************************************************************
// f_isDisturbed()
//*****************************************************************************
//verifica se ha algum flag de perturbacao:
//statf_hallucinating|statf_fly|statf_stone|statf_polymorph|statf_war|statf_sleeping|statf_freeze|statf_dead
[FUNCTION f_isDisturbed]
if (<flags>&000540436) || (<wasDisturbed>)
    return 1
endif
return 0

//*****************************************************************************
// f_gmLog( text )
//*****************************************************************************
//exibe sysmensage para gms dentro da area da tela SOMENTE se var.gmlog estiver 
//ativo
[FUNCTION f_gmLog]
if (!<var0.gmlog>)
    return
endif
FORCLIENTS
    if (<gm>)
        sysmessageyellow <args>
    endif
ENDFOR


//*****************************************************************************
// f_npcRunStepToUid( [uid_to_go], steps,[px,py]  )
//*****************************************************************************
//npc corre em dire  o ao UID
//default: NPC que ira correr
//uid_to_go: uid alvo
//steps numero de 'run's que ira dar em direcao ao alvo
[FUNCTION f_npcRunStepToUid]
REF1=<argv0>
if (<REF1>)
    LOCAL.dx = <eval <REF1.p.x>-<p.x>>
    LOCAL.dy = <eval <REF1.p.y>-<p.y>>
else
    LOCAL.dx = <eval <argv2>-<p.x>>
    LOCAL.dy = <eval <argv3>-<p.y>>
endif

LOCAL.run=0
if ( <LOCAL.dx> > 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SE
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NE
       else
               LOCAL.run=E
       endif
elif ( <LOCAL.dx> < 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SW
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NW
       else
               LOCAL.run=W
       endif
else
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=S
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=N
       endif
endif

if !( 0<LOCAL.run>==0 )
       for R <argv1>
               run <LOCAL.run>
       endfor
       return 1
endif

return 0


//*****************************************************************************
// HILIGHT <UID>, <COLOR>
//*****************************************************************************
//Faz <UID> parecer ter cor <color> pada o default por 3 segundos.
[FUNCTION hilight]
OBJ=<argv0>
LOCAL.y=<eval <obj.p.y>|08000>
SENDPACKET 01A W16 D<obj.uid> W<obj.dispiddec> W<obj.p.x> W<LOCAL.y> B<obj.p.z> W<argv1>
obj.timerf 3,update

//*****************************************************************************
// blindItemMsg <UID>, <COLOR>, <message>
//*****************************************************************************
//Faz <UID> mandar <message> em <color> para o default.
[function blindItemMsg]
sendpacket 01c W<hval strlen(<argv2>) + 45> D<argv0> W0FFFF B07 W<argv1> W03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 <asc <ARGV2>> 00

//*****************************************************************************
// dumpChar
//*****************************************************************************
//faz um dump completo do char na console
[FUNCTION dumpChar]
serv.log *********************** DUMP CHAR *************************
serv.log UID:<uid> F:<flags> ACCT:<account> NAME:<tag.name>
serv.log ************************* EQUIP ***************************
for layer 1 24
    obj=<findlayer.<local.layer>>
    if (<obj>)
        serv.log U:<obj> A:<obj.attr> T:<obj.timer> B:<obj.baseid> L:<LOCAL.layer> N:<obj.name>
    endif
endfor
serv.log *********************** MEMORIES **************************
forcharlayer 30
    serv.log U:<uid> A:<attr> T:<timer> B:<baseid> N:<name>
endfor
serv.log ************************ EVENTS ***************************
LOCAL.c=<events>
while (!strmatch(<LOCAL.c>,0))
    serv.log <strarg <LOCAL.c>>
    LOCAL.c=<streat <LOCAL.c>>
end
serv.log ************************* TAGS ****************************
LOCAL.c=<eval <tagcount>-1>
for i 0 <LOCAL.c>
    serv.log <tagat.<local.i>>
endfor
serv.log ***************** CTAGS [CONSOLE ONLY] ********************
ctaglist log
serv.log *********************** END DUMP **************************

//*****************************************************************************
// movedir <dir>
//*****************************************************************************
//Faz <UID> andar 1 tile na direção <dir>
[FUNCTION movedir]
DOSWITCH <argn1>
 MOVE N
 MOVE NE
 MOVE E
 MOVE SE
 MOVE S
 MOVE SW
 MOVE W
 MOVE NW
ENDDO

//*****************************************************************************
// stun <tempo>
//*****************************************************************************
//Paraliza o char por <tempo> segundos.
[FUNCTION stun]
if (!<IsGM>)
 if (<IsStunned>)
  findid.i_stun.more2 += <argn>
  sysmessagered Sua paralizia piorou!
 else
  serv.newitem i_stun
  equip <new>
  new.more2 <argn>
  new.timer=1
 endif
endif

[FUNCTION IsStunned]
if (<restest 1 i_stun>)
 return 1
endif
return 0

[ITEMDEF i_stun]
//memory de paralização total
ID=i_rune_paralyze
type=t_eq_script
name=Stun
layer=layer_special

on=@equip
src.flags |= statf_freeze
src.sysmessagered Voce esta paralizado!
more1=<src>

on=@timer
//se fim do stun, ou removido por outros meios, ou morto, ou em sleep
if (!<more2>) || !(<cont.flags>&statf_freeze) || (<cont.flags>&012) //Dead ou sleep
    remove
else
    timer = 1
    more2 -= 1
endif
return 1

on=@destroy
obj=<more1>
obj.flags &= ~statf_freeze

//*****************************************************************************
// nomove <tempo>
//*****************************************************************************
//Paraliza o char por <tempo> segundos mas permite ações como skills, magia, luta e usar objetos.
[FUNCTION nomove]
if (!<IsGM>)
 if (<IsNomove>)
  tag.nomovetill += <eval <argn>*10>
  sysmessagered Sua imobilidade piorou!
 else
  tag.nomovetill = <eval <serv.time>+(<argn>*10)>
  sysmessagered Voce nao consegue andar!
 endif
endif

[FUNCTION IsNomove]
if (<tag0.nomovetill> > <serv.time>)
 return 1
endif
return 0

//*****************************************************************************
// f_consumeMana <mana>
//*****************************************************************************
//Tenta consumir <argn> mana. Se tiver o suficiente retorna 1.
//Se não tiver, não consome e retorna 0.
[FUNCTION f_consumeMana]
IF (<IsGM>)
 return 1
ELIF (<mana> >= <argn>)
 mana=<mana>-<argn>
 return 1
ENDIF
return 0

//*****************************************************************************
// aid
//*****************************************************************************
//Revive, revitaliza e cura um char. Usar .set aid ou .xaid em outros chars
[FUNCTION aid]
if <restest 1 i_mry_desmaio>
    f_returnToLife
    morte_decrementaDesmaios 1
endif
hits = <maxhits>
mana = <maxmana>
stam = <maxstam>
if <IsPoisoned>
    spelleffect s_cure,200.0 <UID>
endif

//*****************************************************************************
// f_personalLight <0 a 30>
//*****************************************************************************
//Troca a luz do client por sendpack
//0 nesse caso eh escuro e 30 claro
[function f_personalLight]
if (<IsPLayer>)
    if (<IsOnline>)
       sendpacket 04E D<uid> <hval <args>>
    endif
endif

//*****************************************************************************
//psfx <sound_id>
//*****************************************************************************
//toca um som
//Flags = 0 repeating, 1 = single play
[FUNCTION psfx]
if (<IsPLayer>)
    if (<IsOnline>)
        //ID FLAGS EFFECT VOLUME X Y Z
       sendpacket 054 001 W<argv0> W0FF W<p.x> W<p.y> W<p.z>
    endif
endif

//*****************************************************************************
// ISMYENEMY <UID>
//*****************************************************************************
//Retorna se <argn1> é meu inimigo ou não
[FUNCTION ISMYENEMY]
//Função principal
ref1=<argn>
if (<f_enemyCheck <ref1.uid>>) || (<ref1.f_enemyCheck <UID>>)
 return 1
endif
return 0

[FUNCTION f_enemyCheck]
//Função coadjuvante
ref1=<argn1>
FORCHARLAYER 30
 IF (<LINK>==<ref1.UID>) && (<COLOR>&(memory_fight|memory_iaggressor|memory_harmedby|memory_aggreived|memory_war_targ))
  LOCAL.ret=1
 ENDIF
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// ISMYMASTER <UID>
//*****************************************************************************
//Retorna se sou pet de <argn1> ou não
[FUNCTION ISMYMASTER]
obj=<argn1>
FORCHARLAYER 30
 IF (<LINK>==<obj.UID>) && (<COLOR>&memory_ipet)
  LOCAL.ret=1
 ENDIF
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// IsAnao
//*****************************************************************************
//Retorna se sou anao
[FUNCTION IsAnao]
IF (STRMATCH(Anao,<tag.raca>))
 return 1
ENDIF
return 0

//*****************************************************************************
// IsElfo
//*****************************************************************************
//Retorna se sou elfo
[FUNCTION IsElfo]
IF (STRMATCH(Elfo,<tag.raca>))
 return 1
ENDIF
return 0

//*****************************************************************************
// IsDrow
//*****************************************************************************
//Retorna se sou drow
[FUNCTION IsDrow]
IF (STRMATCH(Drow,<tag.raca>))
 return 1
ENDIF
return 0

//*****************************************************************************
// IsHumano
//*****************************************************************************
//Retorna se sou humano
[FUNCTION IsHumano]
IF (STRMATCH(Humano,<tag.raca>))
 return 1
ENDIF
return 0

//*****************************************************************************
// IsOrc
//*****************************************************************************
//Retorna se sou orc
[FUNCTION IsOrc]
IF (STRMATCH(Orc,<tag.raca>))
 return 1
ENDIF
return 0

//*****************************************************************************
// f_timestring <num>
//*****************************************************************************
//retorna uma string ##d##h##m##s
[FUNCTION f_timestring]
if (<ISEMPTY <args>>)
 return 0
endif

LOCAL.d = <eval <args>/86400>
args = <eval <args>-(<LOCAL.d>*86400)>
LOCAL.h = <eval <args>/3600>
args = <eval <args>-(<LOCAL.h>*3600)>
LOCAL.m = <eval <args>/60>
args = <eval <args>-(<LOCAL.m>*60)>

if (<local.d>)
 local.t = "<dlocal.d>dias"
 if (<local.h>)
  local.t .= " <dlocal.h>h"
  if (<local.m>)
   local.t .= "<dlocal.m>min"
  endif
 elif (<local.m>)
  local.t .= " <dlocal.m>min"
 endif
 if (<args>)
  local.t .= " e <eval <args>>s"
 endif
elif (<local.h>)
 local.t = <dlocal.h>h
 if (<dlocal.m>)
  local.t .= "<dlocal.m>min"
 endif
 if (<args>)
  local.t .= " e <eval <args>>s"
 endif
elif (<local.m>)
 local.t=<dlocal.m>min
 if (<args>)
  local.t .= " e <eval <args>>s"
 endif
elif (<args>)
 local.t = <eval <args>>s
else
 local.t=0s
endif
return <local.t>  


//*****************************************************************************
// correct_disp
//*****************************************************************************
//Força correão de resdisp de todas as contas.
[FUNCTION correct_disp]
FOR acc 0 <eval <serv.accounts>-1>
 if (<serv.account.<local.acc>.resdisp> =! 5) || (<ISEMPTY <serv.account.<local.acc>.resdisp>>)
  serv.account.<local.acc>.resdisp = 5
  LOCAL.c += 1
 endif
 local.i += 1
endfor
sysmessageyellow Corrigiras <dLOCAL.c> contas de <dLOCAL.i>.

//*****************************************************************************
// disturb
//*****************************************************************************
//Marca cTAG.disturb=1 de quem carrega estes events e é perturbado.
[EVENTS e_no_attack]
on=@hit
disturb

//on=@GetHit foi adicionado no sistema de combate o efeito de disturb
//disturb

on=@SpellEffect
disturb

[EVENTS e_no_dclick]
on=@itemdclick
disturb

on=@SkillStart
disturb

[FUNCTION disturb]
if <NPC>
    TAG.disturb 1
else
    cTAG.disturb 1
endif

[FUNCTION wasDisturbed]
if <NPC>
    return <TAG0.disturb>
endif
return <cTAG0.disturb>

//#######################################################
// f_RemoveList <item>,<lista>
//#######################################################
//Remove <item> de uma lista de UIDs separada por ; em <lista>
//e retorna <lista> sem <item>.
[FUNCTION f_RemoveList]
LOCAL.pat=<argv0>
LOCAL.parts=<EXPLODE ;,<argv1>>
//SAY <LOCAL.pat>
//SYSMESSAGE <LOCAL.parts>
_f_RemoveList <LOCAL.pat>,<LOCAL.parts>
timerf 1,VAR.ret,
if (STRMATCH(00,<var.ret>))
 RETURN
ENDIF
RETURN <VAR.ret>

[FUNCTION _f_RemoveList]
LOCAL.lARG=<eval <argv>-1>
FOR i 2 <LOCAL.lARG>
 LOCAL.arg=<ARGV[<LOCAL.i>]>
 IF (<ISNUM <LOCAL.arg>>)
  IF (<LOCAL.arg> != 0) && (<LOCAL.arg>!=<ARGV[0]>) && (<LOCAL.arg>)
   LOCAL.ret=<LOCAL.ret>;<LOCAL.arg>
  ENDIF
 ENDIF
ENDFOR
LOCAL.ret=<STRSUB 2 STRLEN(<LOCAL.ret>) <LOCAL.ret>>
VAR.ret=<LOCAL.ret>

//*****************************************************************************
// uid.RealAR [defname]
//*****************************************************************************
//Retorna a AR real de uma armadura, como se fosse equipada.
//Se não há <argv>, determina a AR de DEFAULT.
//Se há <argv>, determina a AR do item com DEFNAME=<argv>
[FUNCTION RealAR]
if <argv>
 local.ar=<serv.itemdef.<argv0>.ARMOR.HI>
 local.layer=<serv.itemdef.<argv0>.layer>
elif <IsArmor>
 local.ar=<ARMOR.HI>
 local.layer=<layer>
else
 RETURN 0
endif
DOSWITCH <local.layer>
 local.factor=0        //Sem layer 
 local.factor=0        //layer_hand1
 local.factor=0        //layer_hand2
 local.factor=5        //layer_shoes
 local.factor=20       //layer_pants
 local.factor=40       //layer_shirt
 local.factor=10       //layer_helm
 local.factor=10       //layer_gloves
 local.factor=0        //layer_ring
 local.factor=0        //layer_talisman
 local.factor=5        //layer_collar
 local.factor=0        //layer_hair
 local.factor=20       //layer_half_apron
 local.factor=40       //layer_chest
 local.factor=0        //layer_wrist
 local.factor=0        //layer_light
 local.factor=0        //layer_beard
 local.factor=40       //layer_tunic
 local.factor=0        //layer_ears
 local.factor=10       //layer_arms
 local.factor=20       //layer_cape
 local.factor=0        //layer_pack
 local.factor=70       //layer_robe
 local.factor=20       //layer_skirt
 local.factor=25       //layer_legs
END
RETURN <eval (<local.factor>*<local.AR>)/100>
 

//*****************************************************************************
// formatDecimal( number )
//*****************************************************************************
//o sphere se enrosca quando usa FLOAT. com float ele sempre mostra em
//decimal, e com inteiro ele mostra em hex.
//essa funcao retorna sempre decimal
[FUNCTION formatDecimal]
if (<strpos 0 . <argv0>> > 0)
    return <argv0>          //xxx.yyy
else
    return <eval <argv0>>   //xxx
endif

//*****************************************************************************
// maximum a,b,c...n
//*****************************************************************************
//Retorna o maior valor dos argumentos.
//xxxxx=<maximum 5,7,12,-1,120.0,750,0>
[FUNCTION maximum]
local.ret=<argv[0]>
for i 1 <eval <argv>-1>
 if (<argv[<local.i>]> > <local.ret>)
  local.ret=<argv[<local.i>]>
 endif
end
return <local.ret>

//*****************************************************************************
// minimum a,b,c...n
//*****************************************************************************
//Retorna o menor valor dos argumentos.
//xxxxx=<minimum 5,7,12,-1,120.0,750,0>
[FUNCTION minimum]
local.ret=<argv[0]>
for i 1 <eval <argv>-1>
 if (<argv[<local.i>]> < <local.ret>)
  local.ret=<argv[<local.i>]>
 endif
end
return <local.ret>

//*****************************************************************************
// minimumN a,b,c...n
//*****************************************************************************
//Retorna o menor valor dos argumentos como número natural.
//Ou seja, se o valor for < 0, ele retorna 0.
//xxxxx=<minimum 5,7,12,-1,120.0,750>
[FUNCTION minimumn]
local.ret=<minimum <args>>
IF (<local.ret> < 0)
 return 0
ENDIF
return <local.ret>

//*****************************************************************************
// mean a,b,c...n
//*****************************************************************************
//Retorna a media dos argumentos.
//xxxxx=<mean 5,7,12,-1,120.0,750,0>
[FUNCTION mean]
local.ret=0
for i 0 <eval <argv>-1>
 local.ret += <argv[<local.i>]>
end
return <eval <local.ret>/<argv>>

//*****************************************************************************
// guard (uidToGuard) XXX
//*****************************************************************************
[FUNCTION guard]
serv.newitem=i_memory
new.color=memory_guard
new.more1=0
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.timer=60*60*4
new.name=Guard

//*****************************************************************************
// friend (uidFriend)
//*****************************************************************************
[FUNCTION friend]
serv.newitem=i_memory
new.color=memory_friend
new.more1=0
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.timer=60*60*4
new.name=Friend

//*****************************************************************************
// transfer (uidToTransfer)
//*****************************************************************************
[FUNCTION transfer]
memoryfindtype.memory_ipet.remove
serv.newitem=i_memory
new.color=memory_ipet
new.more1=04
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.name=Pet
flags=<flags>|statf_pet

//*****************************************************************************
// setmemory (<memory_type>,<UID>)
//*****************************************************************************
[FUNCTION setmemory]
FORCHARLAYER 30
    if (<TYPE>==t_eq_memory_obj) && (<link>==<argv1>)
        color |= <argv0>
        obj=<argv1>
        IF (<obj.isplayer>) && (!<IsEmpty <obj.tag.name>>)
            name=<obj.tag.name>
        ELSE
            name=<obj.name>
        ENDIF
        return 1
    endif
ENDFOR

serv.newitem i_memory
new.color=<argv0>
new.cont=<uid>
new.timer=1200
new.link=<argv1>
obj=<argv1>
IF (<obj.isplayer>) && (!<IsEmpty <obj.tag.name>>)
    new.name=<obj.tag.name>
ELSE
    new.name=<obj.name>
ENDIF

//*****************************************************************************
// npc_follow (uidFollowed)
//*****************************************************************************
[FUNCTION npc_follow]
action=064
act=<argn>

//*****************************************************************************
// npc_move (xTo,yTo,zTo)
//*****************************************************************************
[FUNCTION npc_move]
action=066
actp=<args>

//*****************************************************************************
// npc_stop()
//*****************************************************************************
[FUNCTION npc_stop]
action=065
tag.stop=1
flags=<flags>&~statf_war

//*****************************************************************************
// npc_wander()
//*****************************************************************************
[FUNCTION npc_wander]
action=067

//*****************************************************************************
// npc_release()
//*****************************************************************************
[FUNCTION npc_release]
memoryfindtype.memory_ipet.remove

//*****************************************************************************
// liquidcont <LIQUID_*>
//*****************************************************************************
//Verifica o quanto de liquido LIQUID_* o default tem.
[FUNCTION liquidcont]
IF (<IsEmpty <argv[0]>>)
 return 0
endif
IF (!<IsNum <argv[0]>>)
 IF (STRMATCH(LIQUID_*,<argv[0]>))
  LOCAL.liq=<DEF.<argv[0]>>
 ELSE
  RETURN 0
 ENDIF
ELSE
 LOCAL.liq=<argv[0]>
ENDIF
FORCONTTYPE t_recipient 2
 if (<more2>==<LOCAL.liq>)
  LOCAL.ret += <more1>
 endif
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// liquidtest <amount>,<LIQUID_*>
//*****************************************************************************
//Retorna 1 se o DEFAULT tem <amount> doses de LIQUID_*. Retorna 0 se não tiver.
[FUNCTION liquidtest]
IF (<IsEmpty <argv[1]>>)
 LOCAL.qtd=1
 LOCAL.liq=<argv[0]>
ELSE
 LOCAL.qtd=<argv[0]>
 LOCAL.liq=<argv[1]>
ENDIF
IF (<liquidcont <LOCAL.liq>> >= <LOCAL.qtd>)
 RETURN 1
ELSE
 RETURN 0
ENDIF

//*****************************************************************************
// consumeliquid <amount>,<LIQUID_*>
//*****************************************************************************
//Consome <amount> doses de LIQUID_* e retorna 1. Se não tiver o suficiente,
// consome tudo que tiver porem retorna 0
[FUNCTION consumeliquid]
IF (<IsEmpty <argv[1]>>)
 LOCAL.qtd=1
 LOCAL.liq=<argv[0]>
ELSE
 LOCAL.qtd=<argv[0]>
 LOCAL.liq=<argv[1]>
ENDIF
IF (!<IsNum <LOCAL.liq>>)
 IF (STRMATCH(LIQUID_*,<LOCAL.liq>))
  LOCAL.liq=<DEF.<LOCAL.liq>>
 ELSE
  say esquece
  RETURN 0
 ENDIF
ENDIF
FORCONTTYPE t_recipient 2
 if (<more2>==<LOCAL.liq>)
  LOCAL.qtd -= <ConsumeRecipient <LOCAL.qtd>>
  IF (<LOCAL.qtd> <= 0)
   RETURN 1
  ENDIF
 endif
ENDFOR
RETURN 0

//*****************************************************************************
// split_key_val( string )
//*****************************************************************************
//separa uma string q esteja no formato "valor chave, valor chave" em uma tabela
//temporaria.
//o numero de linhas é encontrado em ctag.spkv_keys
//os resultados estao em ctag.spkv_rXX_k para chaves e ctag.spkv_rXX_v para valores
//XX vai de 0 a (ctag.spkv_keys - 1)
//um exemplo de uso pode ser para separar a lista de foodtype dos NPCs

//key separator: ','
//val separator: ' '
[FUNCTION split_key_val]

LOCAL.s=<args>
LOCAL.i=<strpos 0 , <LOCAL.s>>
ctag.spkv_keys=0

if (strlen(<args>)<=1)
    return
endif

while ( <LOCAL.i> > 0 && <ctag0.spkv_keys=0> < 10 )
    split_key_val_ <strsub 0 <LOCAL.i> <LOCAL.s>>

    LOCAL.s=<strsub <eval <LOCAL.i>+1> 60 <LOCAL.s>>
    LOCAL.i=<strpos 0 , <LOCAL.s>>
endwhile
split_key_val_ <LOCAL.s>

[FUNCTION split_key_val_]
LOCAL.s=<strtrim <args>>
LOCAL.a=<strarg <LOCAL.s>>
LOCAL.b=<streat <LOCAL.s>>

if (strlen(<LOCAL.b>)>1)
    ctag.spkv_r<ctag.spkv_keys>_k=<LOCAL.b>
    ctag.spkv_r<ctag.spkv_keys>_v=<LOCAL.a>
else
    ctag.spkv_r<ctag.spkv_keys>_k=<LOCAL.a>
    ctag.spkv_r<ctag.spkv_keys>_v=0
endif
ctag.spkv_keys += 1

//*****************************************************************************
// UID.inContainer( containerUid )
//*****************************************************************************
//retorna 1 se UID estiver no container containerUid
[FUNCTION inContainer]
REF1=<argv0>
//ignora se chegar em um char/player
if (<IsChar>)//(<uid> < 040000000)
    //serv.log [inContainer] Alcancou char
    return 0
//ok, achou    
elif (<cont>==<ref1>)
    //serv.log [inContainer] <cont.name> (<cont>) == <ref1.name> (<ref1>) Achou.
    return 1
//nao eh mas tem mais container pra procurar
elif (<cont>)
    //serv.log [inContainer]  <cont.name> (<cont>) != <ref1.name> (<ref1>) (container a cima <cont.name>)
    return <cont.inContainer <ref1>>
//acabou, nao achou
else
    //serv.log [inContainer]  <cont.name> (<cont>) != <ref1.name> (<ref1>) Fim.
    return 0
endif

//*****************************************************************************
// UID.inSpecialLayer
//*****************************************************************************
//retorna 1 se UID estiver numa layer que seja container, mas invisível.
//ie.: bank, special, vendor_*
[FUNCTION inSpecialLayer]
REF1=<argv0>
//ignora se chegar em um char/player
if (<IsChar>)
    //serv.log [inSpecialLayer] Alcancou char
    return 0
//está equipado e em layer especial
elif ( <z> == <layer> ) && ( <layer> > 24)
    //serv.log [inSpecialLayer] <name> (<UID>) Estou na layer <layer>. Achou.
    return 1
//nao eh mas tem mais container pra procurar
elif (<cont>)
    //serv.log [inSpecialLayer] <name> (<UID>) nao tenho layer especial (container a cima <cont.name>)
    return <cont.inSpecialLayer>
//acabou, nao achou
else
   // serv.log [inSpecialLayer] <name> (<uid>) Sou topobj. Fim.
    return 0
endif

//*****************************************************************************
// skillchance <skillValue>,<valueRequired>,[<-3dbDistance>]
//*****************************************************************************
//rotina do TARAN similar a skillcheck
//retorna uma chance, de 0 a 1000 baseado no valor fornecido skillValue, o valor
//de comparação valueRequired e o valor de -3dB da curva boca de sino.
[FUNCTION skillchance]
LOCAL.db=<argv2>
if !<argv2>
    LOCAL.db=100
endif
LOCAL.skill_diff=<eval <argv1>-<argv0>>
LOCAL.skill_bell=<eval randbell( <LOCAL.skill_diff>,<LOCAL.db>)>
if <LOCAL.skill_diff> < 0
    LOCAL.skill_bell=<eval 1000 - <LOCAL.skill_bell>>
endif
return <LOCAL.skill_bell>

//*****************************************************************************
// belltest <skillValue>,<valueRequired>,[<-3dbDistance>]
//*****************************************************************************
[FUNCTION belltest]
if <R1000> < <skillchance <argv0>,<argv1>,<argv2>>
    return 1
else
    return 0
endif

//*****************************************************************************
// skill_repeat <gain_skill>
//*****************************************************************************
//Repete a ultima skill (<argn1>) de gather resource. Ganha skill nesse swing se <argn2>
[FUNCTION skill_repeat]
if (0<argn2>)
 skill_gain <src.action>
endif
if (!<findlayer.layer_hand1>)
 ref1=<findlayer.layer_hand2>
else
 ref1=<findlayer.layer_hand1>
endif
if (<ref1>)
 ref1.hits -= 1
 if (<ref1.hits> < 1)
  sysmessageorange <ref1.name> se quebrou!
  ref1.remove
  return 1
 elif (<IsGM>) || (<ref1.attr>&01)
  ref1.update
 endif
endif
timerf 1 action=<argn1>


//*****************************************************************************
// playeritem
//*****************************************************************************
//Mostra quanto de um determinado ID o player tem na bag + bank. ou num target container qualquer
[FUNCTION playeritem]
if <isempty <args>>
//    sysmessageyellow Use .playeritem ITEM_ID
    promptconsole playeritem Qual ITEM_ID?
elif <argo>
    LOCAL.pack=<argo.rescount <args>>
    LOCAL.bank=<argo.findlayer.layer_bankbox.rescount <args>>
    LOCAL.total=<eval <LOCAL.pack>+<LOCAL.bank>>
    sysmessagegreen <argo.tag.name> tem <dLOCAL.total> <args>.
else
    sysmessagered Selecione o alvo:
    targetfg playeritem <args>
endif

//*****************************************************************************
// unstack
//*****************************************************************************
[FUNCTION unstack]

if (!<argo>)
    src.sysmessageyellow Selecione o item para desempilhar.
    targetf unstack <argv0>
    return 1
endif

LOCAL.x=1
if (<isnum <argv0>>)
    if (<argv0> > 0)
        LOCAL.x=<argv0>
    endif
endif

//Correção do bug de amount de corpses. Não tem outro meio MESMO!
if (<argo.type>==t_corpse)
    src.sysmessageyellow Selecione o item para desempilhar.
    targetf unstack <argv0>
    return 1
endif

if (<LOCAL.x> >= <argo.amount>)
    src.sysmessageyellow Nao pode tirar <eval <argo.amount>> ou mais.
else
    argo.amount -= <LOCAL.x>
    argo.update
    //copia item
    serv.newdupe <argo.uid>
    new.amount=<LOCAL.x>
    //muda color pra nao dar stack de novo
    new.color=-1
    //bounce primeiro pra colocar em posicao diferente na bag
    new.bounce
    new.cont=<argo.cont>
    new.color=<argo.color>
    src.sysmessageyellow <dLOCAL.x> removido(s) da pilha. Ficaram: <eval <argo.amount>>
endif

//*****************************************************************************
// splitStack stack,amount
//*****************************************************************************
//return a dupe or the original with 'amount'
[FUNCTION splitStack]
REF1=<argv0>
LOCAL.amount=<argv1>

if ( <LOCAL.amount> < <REF1.amount> )

    //duplica item, arruma a quantidade
    SERV.NEWDUPE <REF1>
    NEW.amount = <LOCAL.amount>

    //acerta quantidade restante
    REF1.decrement <LOCAL.amount>

    return <NEW>
else
    return <REF1>
endif

//*****************************************************************************
// giveUniqueItem
//*****************************************************************************
[FUNCTION giveUniqueItem]
wipeObject <args>
serv.newitem <args>
src.bounce <new>

//*****************************************************************************
// worldrespawn
//*****************************************************************************
//Reseta os spawnpoints de todo o world. Deixar PLEVEL 6
[FUNCTION worldrespawn]
ctag.lastp=<p>
obj=<uid>
local.i=0
serv.b Aguarde enquanto o mundo eh repopulado.
FORITEMS 6144
 IF (<TYPE> == t_spawn_char) 
  obj.p=<p>
  obj.dclick <uid>
  timerd=<R4,30>
  local.i += 1
 ENDIF
END
p=<ctag.lastp>
ctag.lastp=
sysmessagered Reiniciados <dlocal.i> spawn points.
serv.b Fim da repopulacao mundial.

//*****************************************************************************
// ToPatch
//*****************************************************************************
//Deixa um item com o type original e remove quaisuqer MOREs e TAGs existentes.
[FUNCTION ToPatch]
type=<serv.itemdef.<defname>.type>
more1=
more2=
morep=
attr=010
cleartags
timer=-1

//*****************************************************************************
// addspace
//*****************************************************************************
[FUNCTION addspace]
//Imprime o caractere espaço
local.s=a a
return <strsub 1,1,<local.s>>

//*****************************************************************************
// upd
//*****************************************************************************
//baixa atualizacoes e resynch server
[FUNCTION upd]
event_server SVN Update <args>
src.sysmessageyellow Atualizando scripts: <sysspawn bash up <strarg <args>>> Resynch em 20 segundos
timerf 20,serv.resync 1

//*****************************************************************************
// ABSVAL
//*****************************************************************************
//retorna valor absoluto
[FUNCTION ABSVAL]
if <argn> < 0
    return <eval 0 - <argn>>
endif
return <argn>

//*****************************************************************************
// inspectCont
//*****************************************************************************
//Inspeciona um container que não pode ser aberto por motivo de crash
[FUNCTION inspectCont]
if (!<argo>)
    sysmessageyellow Selecione o container:
    targetf inspectCont
elif (<argo.type>!=t_container) && (<argo.type>!=t_container_locked)
    sysmessagered Isso nao eh container.
else
    list_new Conteudo de <argo.name>:
    list_setAction inspectCont_tweak
    list_setActionBack
    list_newCol 25,UID
    list_newCol 100,Nome
    list_newCol 300,Type
    list_newCol 450,Amt
    list_newCol 500,CONTP
    local.i=0
    cTAG.list_numItems=0
    FORCONT <argo> 10
        src.cTAG.list_numItems += 1
        src.cTAG.list_row<src.cTAG.list_numItems>_01=<UID>
        src.cTAG.list_row<src.cTAG.list_numItems>_02=<name>
        src.cTAG.list_row<src.cTAG.list_numItems>_03=<type>
        src.cTAG.list_row<src.cTAG.list_numItems>_04=.<eval <amount>>
        src.cTAG.list_row<src.cTAG.list_numItems>_05=<CONTP>
    ENDFOR
    cTAG.list_numPages=<eval (<cTAG.list_numItems>/15)+1>
    list_show 1
endif

[FUNCTION inspectCont_tweak]
uid.<cTAG.list_row<hval <argn>>_01>.tweak
clearctags list_

[FUNCTION fixgold]
if !<argn>
    serv.b Breve lag para manutencao em 15 segundos. Afastem-se dos mobs.
    timerf 15 fixgold 1
else
    local.count=0
    FORINSTANCES i_gold
        if (<type>==t_spell)
            local.count += 1
            remove
        endif
    ENDFOR
    src.sysmessagered Removidas <dlocal.count> irregularidades.
endif

[FUNCTION equip_save]
//Salvando os itens pra uma tag no personagem
TAG.EquipsSalvos = <Findlayer.1>,<Findlayer.2>,<Findlayer.3>,<Findlayer.4>,<Findlayer.5>,<Findlayer.6>,<Findlayer.7>,<Findlayer.8>,<Findlayer.9>,<Findlayer.10>,<Findlayer.11>,<Findlayer.12>,<Findlayer.13>,<Findlayer.14>,<Findlayer.15>,<Findlayer.16>,<Findlayer.17>,<Findlayer.18>,<Findlayer.19>,<Findlayer.20>,<Findlayer.21>,<Findlayer.22>,<Findlayer.23>,<Findlayer.24>

[FUNCTION equip_restore_cloth]

Local.Ref = <tag.EquipsSalvos>   

//pra cada uma das tags 
for x 0 24          

    ref1=<eval <strarg <LOCAL.Ref>>>    //le item da lista
    Local.Ref = <streat <LOCAL.Ref>>           //remova o item da lista

    //esta na bag ainda?    
    if <ref1.topobj> == <uid>
        //re-equip somente roupa basica
        doswitch <local.x>
            local.x=0    //layer_hand1
            local.x=0    //layer_hand2
            equip <ref1>    //layer_shoes
            equip <ref1>    //layer_pants
            equip <ref1>    //layer_shirt
            local.x=0    //layer_helm
            equip <ref1>    //layer_gloves
            equip <ref1>    //layer_ring
            equip <ref1>    //layer_talisman
            equip <ref1>    //layer_collar
            local.x=0    //layer_hair
            local.x=0    //layer_half_apron
            local.x=0    //layer_chest
            local.x=0    //layer_wrist
            local.x=0    //layer_light
            local.x=0    //layer_beard
            local.x=0    //layer_tunic
            equip <ref1>    //layer_ears
            local.x=0    //layer_arms
            local.x=0    //layer_cape
            local.x=0    //layer_pack
            local.x=0    //layer_robe
            local.x=0    //layer_skirt
            local.x=0    //layer_legs
        enddo
    endif

endfor


//****************************************************************************
//
//              Sistema de help
//
//****************************************************************************
[COMMENT HELP]
Esta seção deve ser movida daqui para um novo arquivo assim que depurada.
Sempre que o botão Help do client é acionado, a função HelpPage é chamada.
Foi criado um sistema de Help gump based com links externos para o Wiki
Para abrir o browser para um dado link usa-se o comando WEBLINK <link>

[FUNCTION HelpPage]
upd_repo_info
SDIALOG d_help

[DIALOG d_help]
100,75
page 0
resizepic 50 31 2620 520 400
checkertrans 55 38 510 385
gumppic 0 0 10400
gumppic 0 160 10401
gumppic 0 356 10402
gumppic 538 -2 10410
gumppic 538 160 10411
gumppic 538 356 10412
gumppic 232 45 2501
dtext 241 45 26 Mystical Tales Shard
resizepic 92 87 2620 436 124
dtext 274 93 48 Estatisticas
resizepic 92 226 2620 436 91
resizepic 92 329 2620 436 84
dtext 104 112 166 Existem <serv.clients> jogadores online no momento.
if (<serv.account.<src.account>.plevel>) //jogador regular
 dtext 104 128 166 O servidor esta rodando ha <eval <serv.timeup>/86400> dias desde o ultimo reset.
 dtext 104 144 166 O mundo tem <serv.age> dias, <serv.items> itens e <serv.chars> personagens.
 dtext 104 160 166 O servidor esta usando <eval <serv.mem>/1024>MB de memoria.
else                                    //jogador novo. Sem formulario.
 dtext 104 128 166 Voce ja tentou responder o formulario de admissao <eval <serv.account.<src.account>.tag.form.try>> vezes.
 dtext 104 144 166 Voce pode modificar suas questoes quando quiser
 dtext 104 160 166 atravez desta janela. Use os guias para maiores detalhes.
endif
//dtext 104 176 166 Existe um total de <serv.accounts> contas cadastradas no servidor.
dtext 104 176 166 Versão: <VAR.repo_commit>
dtext 287 232 48 Guias
button 104 252 2224 2223 1 0 1
dtext 128 248 166 Racas
button 104 268 2224 2223 1 0 2
dtext 128 264 166 Ambientacao
button 104 285 2224 2223 1 0 3
dtext 128 280 166 Criacao de personagem
button 306 252 2224 2223 1 0 4
dtext 330 248 166 Skills
button 306 268 2224 2223 1 0 5
dtext 330 264 166 Sistemas diversos
dtext 330 280 166 Tabela de precos
button 306 285 2224 2223 1 0 6
dtext 274 336 48 Problemas?
button 104 356 2224 2223 1 0 7
dtext 128 352 166 Pergunte em nosso Forum
button 104 372 2224 2223 1 0 8
dtext 128 368 166 Reportar um bug/mau-funcionamento
if (<tag0.noPagesTil> > <serv.time>)
    dtext 128 384 025 Pages suspensas por <f_timestring <eval (<tag0.noPagesTil>-<serv.time>)/10>>
else
    button 104 388 2224 2223 1 0 9
    dtext 128 384 166 Chame um Game Master
endif
if !<serv.account.<src.account>.plevel> //guest?
 button 296 388 2224 2223 1 0 10
 dtext 320 384 166 Rever meu formulario
endif
[DIALOG d_help text]
Mystical Tales Shard
Estatisticas
Existem <serv.clients> jogadores online no momento.
O servidor esta rodando ha <serv.age> dias desde o ultimo reset.
Existem <serv.items> itens e <serv.chars> personagens no mundo.
O servidor esta usando <serv.mem>kb de memoria.
Existe um total de <serv.accounts> contas cadastradas no servidor.
Guias
Racas
Classes
Criacao de personagem
Skills
Sistemas diversos
Tabela de precos
Problemas?
Pergunte em nosso Forum
Reportar um bug/mau-funcionamento
Chame um Game Master

[DIALOG d_help button]
ON=1
// Raças
WEBLINK www.myt.com.br/wiki/index.php?title=Ra%C3%A7as

ON=2
// Ambientação
WEBLINK www.wiki.myt.com.br/index.php/Introdu%C3%A7%C3%A3o

ON=3
// Criação de char
WEBLINK www.myt.com.br/wiki/index.php?title=Cria%C3%A7%C3%A3o_de_personagem

ON=4
// Skills
WEBLINK www.wiki.myt.com.br/index.php/Categoria:Skills

ON=5
// Sistemas
WEBLINK www.wiki.myt.com.br/index.php/Categoria:Sistemas

ON=6
// Tabela de preços
SDIALOG d_merchant_guild 2

ON=7
// Forum
WEBLINK forum.myt.com.br/

ON=8
// Bug
WEBLINK www.forum.myt.com.br/index.php?topic=2550

ON=9
// Page
//if (!<serv.account.<src.account>.plevel>)
// sysmessagered Voce ainda nao pode fazer isso...
// return 1
//endif
sysmessagered ATENCAO!!!
sysmessageyellow Descreva seu problema com precisao. Seja direto e nao brinque com este sistema sob pena de prisao!
GMPAGE Other

ON=10
//Formulário
playerform

//replace server version with custom one. fix negative age issue with some
//chars that were created before the tick overflow problem.
[FUNCTION f_age]
//no need to touch if not affected
if <create> >= 0
	return <create>
endif
//fix age applying 2^32 tick offset
return <eval <create>+429496729>

//convert a number to 32bits
[FUNCTION to32]
return <eval <argn>&0ffffffff>

[EOF]
