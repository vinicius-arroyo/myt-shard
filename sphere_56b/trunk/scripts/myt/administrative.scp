[DEFNAME administrative_constants]
SM_RED=028
SM_GREEN=044
SM_BLUE=04
SM_YELLOW=036
SM_ORANGE=02c
SND_GLASS={{03e 041} 1 {038d 0390} 1}
SND_THUNDER={05CE 1 028 1 029 1 0206 1}

[PLEVEL 6]
f_connectDB

//*****************************************************************************
//*****************************************************************************
// FUNCOES
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
// f_oncommand( )
//*****************************************************************************
[FUNCTION f_oncommand]
if strmatch("<args>","xresurrect")
    src.sysmessagered Utilize xress
    return 1
elif (strmatch(hungry,<args>))
    comida
    return 1
endif

//*****************************************************************************
// f_connectDB( )
//*****************************************************************************
[FUNCTION f_connectDB]
DB.CONNECT
if (<DB.CONNECTED>)
    SERV.log MySQL debug: MySQL successfully connected!
else
    SERV.log MySQL debug: MySQL not connected!
endif


//*****************************************************************************
// f_sendMessage( uidPlayer, message, msgColor )
//*****************************************************************************
//envia mensagem para um player online. se estiver offline a mensagem é armazenada no banco
//e entregue no proximo login.
//
// ARGV[0] --> UID destino
// ARGV[1] --> mensagem
// ARGV[2] --> cor (SM_RED,SM_GREEN...etc)
[FUNCTION f_sendMessage]
    
//save OBJ ref.
    LOCAL.obj=<OBJ>
    
    OBJ=<argv[0]>
    if ( <OBJ.isonline> )
        OBJ.sysmessage @<argv[2]> <argv[1]>
    else
        if ( <DB.connected> )
            DB.EXECUTE "INSERT INTO messageBox SET timestamp=NOW(), message='<argv[1]>', status='Pending', triggerUid=<eval <SRC.uid>>, toUid=<eval <argv[0]>>, color=<eval <argv[2]>>"
        endif
    endif
    
    OBJ=<LOCAL.obj>
    
//*****************************************************************************
// f_deliverPendingMessages( )
//*****************************************************************************
//chame essa funcao no login para enviar as mensagens pendentes ao player.  
//SRC é o player fazendo login
[FUNCTION f_deliverPendingMessages]
if ( <DB.connected> )
    DB.QUERY "SELECT message,color FROM messageBox WHERE status='Pending' AND toUid=<eval <SRC.uid>>"
    if (<DB.ROW.NUMROWS> > 0)
        for R 0 <eval <DB.ROW.NUMROWS>-1>
            SRC.sysmessage @<DB.ROW.<eval <LOCAL.R>>.color> <DB.ROW.<eval <LOCAL.R>>.message>
        end
        DB.EXECUTE "UPDATE messageBox SET status='Sent' WHERE toUid=<eval <SRC.uid>>"
    endif
endif
    

//*****************************************************************************
// f_isWeapon( item )
//*****************************************************************************
//retorna 1 se o argumento for uma arma
[FUNCTION f_isWeapon]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_weapon_axe )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_smith )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_sharp )
        return 1
    elif ( <LOCAL.type>==t_weapon_sword )
        return 1
    elif ( <LOCAL.type>==t_weapon_fence )
        return 1
    elif ( <LOCAL.type>==t_weapon_bow )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_staff )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_crook )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_pick )
        return 1
    elif ( <LOCAL.type>==t_weapon_arrow )
        return 1
    elif ( <LOCAL.type>==t_weapon_bolt )
        return 1
    elif ( <LOCAL.type>==t_weapon_xbow )
        return 1
    elif ( <LOCAL.type>==t_string )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isArmor( item )
//*****************************************************************************
//retorna 1 se o argumento for uma armadura (ou escudo)
[FUNCTION f_isArmor]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_armor )
        return 1
    elif ( <LOCAL.type>==t_armor_leather )
        return 1
    elif ( <LOCAL.type>==t_shield )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isRegsOrMagic( item )
//*****************************************************************************
//retorna 1 se o argumento for uma reagente ou magico
[FUNCTION f_isRegsOrMagic]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_wand )
        return 1
    elif ( <LOCAL.type>==t_potion )
        return 1
    elif ( <LOCAL.type>==t_potion_empty )
        return 1
    elif ( <LOCAL.type>==t_reagente )
        return 1
    elif ( <LOCAL.type>==t_almofariz )
        return 1
    elif ( <LOCAL.type>==t_espiriteira )
        return 1
    elif ( <LOCAL.type>==t_destilador )
        return 1
    elif ( <LOCAL.type>==t_balao )
        return 1
    elif ( <LOCAL.type>==t_misturador )
        return 1
    elif ( <LOCAL.type>==t_tubo )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isFood( item )
//*****************************************************************************
//retorna 1 se o argumento for um alimento/comestivel
[FUNCTION f_isFood]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_food )
        return 1
    elif ( <LOCAL.type>==t_food_raw )
        return 1
    elif ( <LOCAL.type>==t_fish )
        return 1
    elif ( <LOCAL.type>==t_fruit )
        return 1
    elif ( <LOCAL.type>==t_meat_raw )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isMisc( item )
//*****************************************************************************
//retorna 1 se o argumento for ferramenta, movel, etc
[FUNCTION f_isMisc]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_clock )
        return 1
    elif ( <LOCAL.type>==t_termometro )
        return 1
    elif ( <LOCAL.type>==t_musical )
        return 1
    elif ( <LOCAL.type>==t_ar_projeto )
        return 1
    elif ( <LOCAL.type>==t_ar_livro )
        return 1
    elif ( <LOCAL.type>==t_carpentry )
        return 1
    elif ( <LOCAL.type>==t_chair )
        return 1
    elif ( <LOCAL.type>==t_sextant )
        return 1
    elif ( <LOCAL.type>==t_table )
        return 1
    elif ( <LOCAL.type>==t_fish_pole )
        return 1
    elif ( <LOCAL.type>==t_shaft )
        return 1
    elif ( <LOCAL.type>==t_tinker_tools )
        return 1
    elif ( <LOCAL.type>==t_carpentry_tool )
        return 1
    elif ( <LOCAL.type>==t_light_out )
        return 1
    elif ( <LOCAL.type>==t_fish_pole )
        return 1
    elif ( <LOCAL.type>==t_oleo )
        return 1
    elif ( <LOCAL.type>==t_book )
        return 1
    elif ( <LOCAL.type>==t_sand )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_preitem_bowcraft )
        return 1
    elif ( <LOCAL.type>==t_preitem_carpentry )
        return 1
    elif ( <LOCAL.type>==t_buy_misc )
        return 1
    elif ( <LOCAL.type>==t_arame )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_luz_oleo )
        return 1        
    elif ( <LOCAL.type>==t_container )
        return 1        
    else
        return 0
    endif

//*****************************************************************************
// f_isWearable( item )
//*****************************************************************************
//retorna 1 se o argumento for roupas, joias, etc
[FUNCTION f_isWearable]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_clothing )
        return 1
    elif ( <LOCAL.type>==t_cloth )
        return 1
    elif ( <LOCAL.type>==t_tailoring )
        return 1
    elif ( <LOCAL.type>==t_thread )
        return 1
    elif ( <LOCAL.type>==t_yarn )
        return 1
    elif ( <LOCAL.type>==t_jewelry )
        return 1
    elif ( <LOCAL.type>==t_bandagem )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isRaw( item )
//*****************************************************************************
//retorna 1 se o argumento for materia prima
[FUNCTION f_isRaw]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_log )
        return 1
    elif ( <LOCAL.type>==t_ore )
        return 1
    elif ( <LOCAL.type>==t_ingot )
        return 1
    elif ( <LOCAL.type>==t_seed )
        return 1
    elif ( <LOCAL.type>==t_leather )
        return 1
    elif ( <LOCAL.type>==t_loom )
        return 1
    elif ( <LOCAL.type>==t_feather )
        return 1
    elif ( <LOCAL.type>==t_wool )
        return 1
    elif ( <LOCAL.type>==t_fur )
        return 1
    elif ( <LOCAL.type>==t_thread )
        return 1
    elif ( <LOCAL.type>==t_yarn )
        return 1
    elif ( <LOCAL.type>==t_cotton )
        return 1
    elif ( <LOCAL.type>==t_preitem_bowcraft )
        return 1
    elif ( <LOCAL.type>==t_preitem_carpentry )
        return 1
    elif ( <LOCAL.type>==t_arame )
        return 1
    elif ( <LOCAL.type>==t_buy_raw )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_hide )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// wipeObject <DEFNAME> Remove todos os itens <DEFNAME> do world.
//*****************************************************************************
[FUNCTION wipeObject]
IF !(<ARGN>)
 IF (<ISEMPTY <DEF.<ARGS>>>)
  SYSMESSAGE <args> nao existe.
  RETURN 0
 endif
endif
IF !(<ISEMPTY <ARGS>>)
 IF !(<SERV.ITEMDEF.<ARGS>>) && !(<SERV.CHARDEF.<ARGS>>)
  SYSMESSAGE <ARGS> nao eh um item nem criatura.
  RETURN 0
 endif
 FORINSTANCES <argv[0]>
  LOCAL.wipe=<local.wipe>+1
  remove
 ENDFOR
 if (<IsGM>)
  sysmessageorange Removidos <eval <LOCAL.wipe>> instancias de <SERV.RESOURCES.<argv[0]>.NAME>
 endif
endif

//*****************************************************************************
//  CRY Faz o char gritar de dor e animar (compatibilidade com 55i)
//*****************************************************************************

[FUNCTION cry]
//// anima
anim 20                     //Animação de @GetHit
bark 3

//*****************************************************************************
//  EFFECTSPELL <spell>,<skill>
//*****************************************************************************
//Retorna o EFFECT de uma magia de acordo com uma skill
//Se a spell tiver spellflag_resist, calcula o retorno para MagicResist do DEFAULT.
[FUNCTION EFFECTSPELL]
if (<isitem>)
    return 1
endif
LOCAL.eff=<SERV.RESOURCES.<argv0>.EFFECT>
LOCAL.skill=<argn1>
LOCAL.min=<strarg <LOCAL.eff>>
LOCAL.eff=<streat <LOCAL.eff>>

//Resisting spells?
if (<serv.resources.<argv0>.FLAGS>&spellflag_resist)
 if (<BELLTEST <MagicResistance>,<LOCAL.skill>>)
  sysmessageblue Voce resiste a magia.
  //Resistir totalmente?
  if (<BELLTEST <MagicResistance>,140.0>)   //Resistir totalmente
   LOCAL.min=0
   LOCAL.eff=0
   sfx 05C1
   emotered resistiu
  else                      //Resistir parcialmente
   LOCAL.eff=<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<eval 1010-<MagicResistance>>>
  endif
 endif
 SKILL_GAIN Skill_MagicResistance
endif

LOCAL.eff=<EVAL {<LOCAL.min> <LOCAL.eff>}>
LOCAL.eff=<f_rangeValue <LOCAL.min>, <LOCAL.eff>, <argv1>>
RETURN <LOCAL.eff>

//*****************************************************************************
//  DAMAGESPELL <spell>,<dam_type>,<skill>,<UIDcaster>
//*****************************************************************************
//Danifica conforme a magia <argv0> com tipo <argv1> como se tivesse magery <argv2> por <<argv3>.UID>
[FUNCTION damagespell]
LOCAL.dam=<EFFECTSPELL <argv0>, <argv2>>
DAMAGE <LOCAL.dam> <EVAL <argv1>> <argv3>                           //aplica o dano com o tipo modificado
RETURN <LOCAL.dam>

//*****************************************************************************
//  IsStonned
//*****************************************************************************
//Retorna se o char está stonnado ou não.
[FUNCTION IsStonned]
if (<restest 1 i_stonned>)
 RETURN 1
else
 RETURN 0
endif

//*****************************************************************************
//  Stonned <tempo>
//*****************************************************************************
//Petrifica um char por <tempo> segundos.
[FUNCTION Stonned]
if (<IsStonned>)
 RETURN 0
endif
serv.newitem i_stonned
new.timer=<argn>
equip <new.uid>
RETURN 1

[ITEMDEF i_stonned]
ID=020A5
NAME=Petrificado
TYPE=t_eq_script
LAYER=layer_special

on=@equip
cont.flags=<cont.flags>|040000
cont.update

on=@timer
cont.flags=<cont.flags>&~040000
cont.sysmessageblue Voce nao esta mais petrificado.
cont.update
remove
RETURN 1

//*****************************************************************************
// emotes
//*****************************************************************************
[FUNCTION emotegreen]
SAY @<DEF.SM_GREEN>,  *<args>*

[FUNCTION emotered]
SAY @<DEF.SM_RED>,  *<args>*

[FUNCTION emoteyellow]
SAY @<DEF.SM_YELLOW>,  *<args>*

[FUNCTION emoteblue]
SAY @<DEF.SM_BLUE>,  *<args>*

[FUNCTION emoteorange]
SAY @<DEF.SM_ORANGE>,  *<args>*

//*****************************************************************************
// sysmessage
//*****************************************************************************
[FUNCTION sysmessagered]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_RED>,3  <args>
endif

[FUNCTION sysmessageblue]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_BLUE>,3  <args> 
endif

[FUNCTION sysmessagegreen]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_GREEN>,3  <args> 
endif

[FUNCTION sysmessageyellow]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_YELLOW>,3  <args> 
endif

[FUNCTION sysmessageorange]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_ORANGE>,3  <args> 
endif

//*****************************************************************************
// decrement
//*****************************************************************************
[FUNCTION decrement]
amount=<amount>-1
if (<amount><1)
    remove
endif
update

//*****************************************************************************
// f_sendTooltip(title,text)
//*****************************************************************************
[FUNCTION f_sendTooltip]
src.addcliloc 1042971,<argv0>
src.addcliloc 1070722,<argv1>

//*****************************************************************************
// f_sendTooltipData(text)
//*****************************************************************************
[FUNCTION f_sendTooltipData]
src.addcliloc 1070722,<argv0>

//*****************************************************************************
// checkVersion([major],[lower],[minor])
//*****************************************************************************
[FUNCTION checkVersion]
if (!0<argv0>)
    return <f_checkVersion <STREAT <explode .,<CLIENTVERSION>>>>
endif
if (<argv0>==6) && (<argv1>==0) && (<argv2>==1)
    src.sysmessageyellow ****************************************************Versao de client 6.0.1.7 CAUSA problemas.
    return 1
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
    return 1
endif
return 0

//*****************************************************************************
// f_checkVersion(major,lower,minor)
//*****************************************************************************
[FUNCTION f_checkVersion]
if (!0<argv0>)
    serv.log Clientversion invalido: <CLIENTVERSION> -- <argv0>::<argv1>::<argv2>
    return 0
endif
if (<argv0>==6) && (<argv1>==0) && (<argv2>==1)
    src.sysmessageyellow ****************************************************Versao de client 6.0.1.7 CAUSA problemas.
    return 1
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
    return 1
endif
return 0

//*****************************************************************************
// f_spreadValue(value,error)
//*****************************************************************************
//dado um valor value, retorn um valor aleatorio V+-K, onde K vai de 0 a
//(V/2) (erro 100%)
//'error' deve ser passado entre 0 (retorna 'value') e Cm (atualmente 50)

//Formula e simplificavao:
//Vn=V*[1+(2*Er-Em)/(2*Cm)]
//Vn=V*[(2*Cm)+(2*Er)-Em)]/(2*Cm)
//Vn=V*[K-Em+(2*Er)]/k
//Vn - valor falso
//V  - valor real ('value')
//Cm - Maximo % de erro (0 a 100). Atualmente ajustado em 50.
//Em - Erro máximo ('error')
//Er - Erro random (0 a Em)
[FUNCTION f_spreadValue]
return <eval (<argv0>*((100-<argv1>)+(2*<R0,<argv1>>)))/100>

//*****************************************************************************
// f_rangeValue(min,max,skill)
//*****************************************************************************
//dado um valor value, retorn um valor de acordo com uma regra de tres
//composta entre <min> e <max> de acordo com <skill>
[FUNCTION f_RangeValue]
LOCAL.min=<argv0>
LOCAL.max=<argv1>
LOCAL.skill=<argv2>
LOCAL.max=<LOCAL.max>-<LOCAL.min>
LOCAL.max=((<LOCAL.max>*<LOCAL.skill>)/1000)+<LOCAL.min>
return <eval <LOCAL.max>>

//*****************************************************************************
// f_isDisturbed()
//*****************************************************************************
//verifica se ha algum flag de perturbacao:
//statf_hallucinating|statf_fly|statf_stone|statf_polymorph|statf_war|statf_sleeping|statf_freeze|statf_dead
[FUNCTION f_isDisturbed]
if (<flags>&000540436)
    return 1
endif
return 0

//*****************************************************************************
// f_gmLog( text )
//*****************************************************************************
//exibe sysmensage para gms dentro da area da tela SOMENTE se var.gmlog estiver 
//ativo
[FUNCTION f_gmLog]
if (!<var0.gmlog>)
    return
endif
FORCLIENTS
    if (<gm>)
        sysmessageyellow <args>
    endif
ENDFOR


//*****************************************************************************
// f_npcRunStepToUid( [uid_to_go], steps,[px,py]  )
//*****************************************************************************
//npc corre em dire  o ao UID
//default: NPC que ira correr
//uid_to_go: uid alvo
//steps numero de 'run's que ira dar em direcao ao alvo
[FUNCTION f_npcRunStepToUid]
REF1=<argv0>
if (<REF1>)
    LOCAL.dx = <eval <REF1.p.x>-<p.x>>
    LOCAL.dy = <eval <REF1.p.y>-<p.y>>
else
    LOCAL.dx = <eval <argv2>-<p.x>>
    LOCAL.dy = <eval <argv3>-<p.y>>
endif

LOCAL.run=0
if ( <LOCAL.dx> > 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SE
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NE
       else
               LOCAL.run=E
       endif
elif ( <LOCAL.dx> < 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SW
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NW
       else
               LOCAL.run=W
       endif
else
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=S
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=N
       endif
endif

if !( 0<LOCAL.run>==0 )
       for R <argv1>
               run <LOCAL.run>
       endfor
       return 1
endif

return 0


//*****************************************************************************
// HILIGHT <UID>, <COLOR>
//*****************************************************************************
//Faz <UID> parecer ter cor <color> pada o default por 3 segundos.
[FUNCTION hilight]
OBJ=<argv0>
LOCAL.y=<eval <obj.p.y>|08000>
SENDPACKET 01A W16 D<obj.uid> W<obj.dispiddec> W<obj.p.x> W<LOCAL.y> B<obj.p.z> W<argv1>
obj.timerf 3,update

//*****************************************************************************
// blindItemMsg <UID>, <COLOR>, <message>
//*****************************************************************************
//Faz <UID> mandar <message> em <color> para o default.
[function blindItemMsg]
sendpacket 01c W<hval strlen(<argv2>) + 45> D<argv0> W0FFFF B07 W<argv1> W03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 <asc <ARGV2>> 00

//*****************************************************************************
// dumpChar
//*****************************************************************************
//faz um dump completo do char na console
[FUNCTION dumpChar]
serv.log *********************** DUMP CHAR *************************
serv.log UID:<uid> F:<flags> ACCT:<account> NAME:<tag.name>
serv.log ************************* EQUIP ***************************
for layer 1 24
    obj=<findlayer.<local.layer>>
    if (<obj>)
        serv.log U:<obj> A:<obj.attr> T:<obj.timer> B:<obj.baseid> L:<LOCAL.layer> N:<obj.name>
    endif
endfor
serv.log *********************** MEMORIES **************************
forcharlayer 30
    serv.log U:<uid> A:<attr> T:<timer> B:<baseid> N:<name>
endfor
serv.log ************************ EVENTS ***************************
LOCAL.c=<events>
while (!strmatch(<LOCAL.c>,0))
    serv.log <strarg <LOCAL.c>>
    LOCAL.c=<streat <LOCAL.c>>
end
serv.log ************************* TAGS ****************************
LOCAL.c=<eval <tagcount>-1>
for i 0 <LOCAL.c>
    serv.log <tagat.<local.i>>
endfor
serv.log ***************** CTAGS [CONSOLE ONLY] ********************
ctaglist log
serv.log *********************** END DUMP **************************

//*****************************************************************************
// movedir <dir>
//*****************************************************************************
//Faz <UID> andar 1 tile na direção <dir>
[FUNCTION movedir]
DOSWITCH <argn1>
 MOVE N
 MOVE NE
 MOVE E
 MOVE SE
 MOVE S
 MOVE SW
 MOVE W
 MOVE NW
ENDDO

//*****************************************************************************
// f_vomita
//*****************************************************************************
//Faz o char fomitar
[FUNCTION f_vomita]
serv.newitem i_vomito
new.p=<p>
new.movedir <dir>
new.timer={8 12}
emotegreen vomita
IF (<isplayer>)
 sfx <SEX 043f/032d>
 anim 20
else
 cry
endif

[ITEMDEF i_vomito]
id=0322e
name=vomito
dye=1

on=@create
dispid={i_blood_pool_large 1 0122d 1 i_blood_smear 1}
color=colors_yellow
type=t_normal
attr=04012
update

//*****************************************************************************
// f_peida
//*****************************************************************************
//Faz o char flatular
[FUNCTION f_peida]
emotegreen flatula
IF (<isplayer>)
 sfx <SEX 0428/0319>
 anim 20
else
 cry
endif

//*****************************************************************************
// f_tosse
//*****************************************************************************
//Faz o char tossir
[FUNCTION f_tosse]
emotegreen tosse
IF (<isplayer>)
 sfx <SEX 0420/0311>
 anim 6
else
 cry
endif

//*****************************************************************************
// f_espirra
//*****************************************************************************
//Faz o char espirrar
[FUNCTION f_espirra]
emotegreen espirra
IF (<isplayer>)
 sfx <SEX 0443/0331>
 anim 6
else
 cry
endif

//*****************************************************************************
// f_arrota
//*****************************************************************************
//Faz o char arrotar
[FUNCTION f_arrota]
emotegreen arrota
IF (<isplayer>)
 sfx <SEX 041d/030e>
 anim 6
else
 cry
endif

//*****************************************************************************
// stun <tempo>
//*****************************************************************************
//Paraliza o char por <tempo> segundos.
[FUNCTION stun]
if (!<IsGM>)
 if (<IsStunned>)
  findid.i_stun.timer += <argn>
  sysmessagered Sua paralizia piorou!
 else
  serv.newitem i_stun
  equip <new>
  new.timer <argn>
 endif
endif

[FUNCTION IsStunned]
if (<src.restest 1 i_stun>)
 return 1
endif
return 0

[ITEMDEF i_stun]
//memory de paralização total
ID=i_rune_paralyze
type=t_eq_script
name=Stun
layer=layer_special

on=@equip
src.flags |= 04
src.sysmessagered Voce esta paralizado!

on=@timer
cont.flags ^= 04
remove
return 1

//*****************************************************************************
// nomove <tempo>
//*****************************************************************************
//Paraliza o char por <tempo> segundos mas permite ações como skills, magia, luta e usar objetos.
[FUNCTION nomove]
if (!<IsGM>)
 if (<IsNomove>)
  tag.nomovetill += <eval <argn>*10>
  sysmessagered Sua imobilidade piorou!
 else
  tag.nomovetill = <eval <serv.time>+(<argn>*10)>
  sysmessagered Voce nao consegue andar!
 endif
endif

[FUNCTION IsNomove]
if (<tag0.nomovetill> > <serv.time>)
 return 1
endif
return 0

//*****************************************************************************
// f_consumeMana <mana>
//*****************************************************************************
//Tenta consumir <argn> mana. Se tiver o suficiente retorna 1.
//Se não tiver, não consome e retorna 0.
[FUNCTION f_consumeMana]
IF (<IsGM>)
 return 1
ELIF (<mana> >= <argn>)
 mana=<mana>-<argn>
 return 1
ENDIF
return 0

//*****************************************************************************
// aid
//*****************************************************************************
//Revive, revitaliza e cura um char. Usar .set aid ou .xaid em outros chars
[FUNCTION aid]
if (<restest 1 i_mry_desmaio>)
 f_returnToLife
endif
hits = <maxhits>
mana = <maxmana>
stam = <maxstam>
if (<IsPoisoned>)
 spelleffect s_cure,200.0 <UID>
endif
tag.morte_desmaios=0

//*****************************************************************************
// f_personalLight <0 a 30>
//*****************************************************************************
//Troca a luz do client por sendpack
[function f_personalLight]
if (<IsPLayer>)
    if (<IsOnline>)
       sendpacket 04E D<uid> <hval <args>>
    endif
endif

//*****************************************************************************
// ISMYENEMY <UID>
//*****************************************************************************
//Retorna se <argn1> é meu inimigo ou não
[FUNCTION ISMYENEMY]
//Função principal
ref1=<argn>
if (<f_enemyCheck <ref1.uid>>) || (<ref1.f_enemyCheck <UID>>)
 return 1
endif
return 0

[FUNCTION f_enemyCheck]
//Função coadjuvante
ref1=<argn1>
FORCHARLAYER 30
 IF (<LINK>==<ref1.UID>) && (<COLOR>&(memory_fight|memory_iaggressor|memory_harmedby|memory_aggreived|memory_war_targ))
  LOCAL.ret=1
 ENDIF
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// ISMYMASTER <UID>
//*****************************************************************************
//Retorna se sou pet de <argn1> ou não
[FUNCTION ISMYMASTER]
obj=<argn1>
FORCHARLAYER 30
 IF (<LINK>==<obj.UID>) && (<COLOR>&memory_ipet)
  LOCAL.ret=1
 ENDIF
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// f_timestring <num>
//*****************************************************************************
//retorna uma string ##d##h##m##s
[FUNCTION f_timestring]
if (<ISEMPTY <argn>>)
 return 0
endif
WHILE (<argn> >= 86400)
 argn -= 86400
 LOCAL.d += 1
END
WHILE (<argn> >= 3600)
 argn -= 3600
 LOCAL.h += 1
END
WHILE (<argn> >= 60)
 argn -= 60
 LOCAL.m += 1
END
RETURN <QVAL <LOCAL.d> ? <dLOCAL.d>d :><QVAL <LOCAL.h> ? <dLOCAL.h>h :><QVAL <LOCAL.m> ? <dLOCAL.m>min :><QVAL <argn> ? <eval <argn>>s :>


//*****************************************************************************
// correct_disp
//*****************************************************************************
//Força correão de resdisp de todas as contas.
[FUNCTION correct_disp]
FOR acc 0 <eval <serv.accounts>-1>
 if (<serv.account.<local.acc>.resdisp> =! 5) || (<ISEMPTY <serv.account.<local.acc>.resdisp>>)
  serv.account.<local.acc>.resdisp = 5
  LOCAL.c += 1
 endif
 local.i += 1
endfor
sysmessageyellow Corrigiras <dLOCAL.c> contas de <dLOCAL.i>.

//*****************************************************************************
// disturb
//*****************************************************************************
//Marca cTAG.disturb=1 de quem carrega estes events e é perturbado.
[EVENTS e_no_attack]
on=@hit
disturb

on=@GetHit
disturb

on=@SpellEffect
disturb

[EVENTS e_no_dclick]
on=@dclick
disturb

on=@itemdclick
disturb

[FUNCTION disturb]
cTAG.disturb 1

//#######################################################
// f_RemoveList <item>,<lista>
//#######################################################
//Remove <item> de uma lista de UIDs separada por ; em <lista>
//e retorna <lista> sem <item>.
[FUNCTION f_RemoveList]
LOCAL.pat=<argv0>
LOCAL.parts=<EXPLODE ;,<argv1>>
//SAY <LOCAL.pat>
//SYSMESSAGE <LOCAL.parts>
_f_RemoveList <LOCAL.pat>,<LOCAL.parts>
timerf 1,VAR.ret,
if (STRMATCH(00,<var.ret>))
 RETURN
ENDIF
RETURN <VAR.ret>

[FUNCTION _f_RemoveList]
LOCAL.lARG=<eval <argv>-1>
FOR i 2 <LOCAL.lARG>
 LOCAL.arg=<ARGV[<LOCAL.i>]>
 IF (<ISNUM <LOCAL.arg>>)
  IF (<LOCAL.arg> != 0) && (<LOCAL.arg>!=<ARGV[0]>) && (<LOCAL.arg>)
   LOCAL.ret=<LOCAL.ret>;<LOCAL.arg>
  ENDIF
 ENDIF
ENDFOR
LOCAL.ret=<STRSUB 2 STRLEN(<LOCAL.ret>) <LOCAL.ret>>
VAR.ret=<LOCAL.ret>

//*****************************************************************************
// formatDecimal( number )
//*****************************************************************************
//o sphere se enrosca quando usa FLOAT. com float ele sempre mostra em
//decimal, e com inteiro ele mostra em hex.
//essa funcao retorna sempre decimal
[FUNCTION formatDecimal]
if (<strpos 0 . <argv0>> > 0)
    return <argv0>          //xxx.yyy
else
    return <eval <argv0>>   //xxx
endif

//*****************************************************************************
// guard (uidToGuard) XXX
//*****************************************************************************
[FUNCTION guard]
serv.newitem=i_memory
new.color=memory_guard
new.more1=0
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.timer=60*60*4
new.name=Guard

//*****************************************************************************
// friend (uidFriend)
//*****************************************************************************
[FUNCTION friend]
serv.newitem=i_memory
new.color=memory_friend
new.more1=0
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.timer=60*60*4
new.name=Friend

//*****************************************************************************
// transfer (uidToTransfer)
//*****************************************************************************
[FUNCTION transfer]
memoryfindtype.memory_ipet.remove
serv.newitem=i_memory
new.color=memory_ipet
new.more1=04
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.name=Pet

//*****************************************************************************
// npc_follow (uidFollowed)
//*****************************************************************************
[FUNCTION npc_follow]
action=064
act=<argn>

//*****************************************************************************
// npc_move (xTo,yTo,zTo)
//*****************************************************************************
[FUNCTION npc_move]
action=066
actp=<args>

//*****************************************************************************
// npc_stop()
//*****************************************************************************
[FUNCTION npc_stop]
action=065
tag.stop=1
flags=<flags>&~statf_war

//*****************************************************************************
// npc_wander()
//*****************************************************************************
[FUNCTION npc_wander]
action=067

//*****************************************************************************
// liquidcont <LIQUID_*>
//*****************************************************************************
//Verifica o quanto de liquido LIQUID_* o default tem.
[FUNCTION liquidcont]
IF (<IsEmpty <argv[0]>>)
 return 0
endif
IF (!<IsNum <argv[0]>>)
 IF (STRMATCH(LIQUID_*,<argv[0]>))
  LOCAL.liq=<DEF.<argv[0]>>
 ELSE
  RETURN 0
 ENDIF
ELSE
 LOCAL.liq=<argv[0]>
ENDIF
FORCONTTYPE t_recipient 2
 if (<more2>==<LOCAL.liq>)
  LOCAL.ret += <more1>
 endif
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// liquidtest <amount>,<LIQUID_*>
//*****************************************************************************
//Retorna 1 se o DEFAULT tem <amount> doses de LIQUID_*. Retorna 0 se não tiver.
[FUNCTION liquidtest]
IF (<IsEmpty <argv[1]>>)
 LOCAL.qtd=1
 LOCAL.liq=<argv[0]>
ELSE
 LOCAL.qtd=<argv[0]>
 LOCAL.liq=<argv[1]>
ENDIF
IF (<liquidcont <LOCAL.liq>> >= <LOCAL.qtd>)
 RETURN 1
ELSE
 RETURN 0
ENDIF

//*****************************************************************************
// consumeliquid <amount>,<LIQUID_*>
//*****************************************************************************
//Consome <amount> doses de LIQUID_* e retorna 1. Se não tiver o suficiente,
// consome tudo que tiver porem retorna 0
[FUNCTION consumeliquid]
IF (<IsEmpty <argv[1]>>)
 LOCAL.qtd=1
 LOCAL.liq=<argv[0]>
ELSE
 LOCAL.qtd=<argv[0]>
 LOCAL.liq=<argv[1]>
ENDIF
IF (!<IsNum <LOCAL.liq>>)
 IF (STRMATCH(LIQUID_*,<LOCAL.liq>))
  LOCAL.liq=<DEF.<LOCAL.liq>>
 ELSE
  say esquece
  RETURN 0
 ENDIF
ENDIF
FORCONTTYPE t_recipient 2
 if (<more2>==<LOCAL.liq>)
  LOCAL.qtd -= <ConsumeRecipient <LOCAL.qtd>>
  IF (<LOCAL.qtd> <= 0)
   RETURN 1
  ENDIF
 endif
ENDFOR
RETURN 0

//*****************************************************************************
// split_key_val( string )
//*****************************************************************************
//separa uma string q esteja no formato "valor chave, valor chave" em uma tabela
//temporaria.
//o numero de linhas é encontrado em ctag.spkv_keys
//os resultados estao em ctag.spkv_rXX_k para chaves e ctag.spkv_rXX_v para valores
//XX vai de 0 a (ctag.spkv_keys - 1)
//um exemplo de uso pode ser para separar a lista de foodtype dos NPCs

//key separator: ','
//val separator: ' '
[FUNCTION split_key_val]

LOCAL.s=<args>
LOCAL.i=<strpos 0 , <LOCAL.s>>
ctag.spkv_keys=0

if (strlen(<args>)<=1)
    return
endif

while ( <LOCAL.i> > 0 && <ctag.spkv_keys=0> < 10 )
    split_key_val_ <strsub 0 <LOCAL.i> <LOCAL.s>>

    LOCAL.s=<strsub <eval <LOCAL.i>+1> 60 <LOCAL.s>>
    LOCAL.i=<strpos 0 , <LOCAL.s>>
endwhile
split_key_val_ <LOCAL.s>

[FUNCTION split_key_val_]
LOCAL.s=<strtrim <args>>
LOCAL.a=<strarg <LOCAL.s>>
LOCAL.b=<streat <LOCAL.s>>

if (strlen(<LOCAL.b>)>1)
    ctag.spkv_r<ctag.spkv_keys>_k=<LOCAL.b>
    ctag.spkv_r<ctag.spkv_keys>_v=<LOCAL.a>
else
    ctag.spkv_r<ctag.spkv_keys>_k=<LOCAL.a>
    ctag.spkv_r<ctag.spkv_keys>_v=0
endif
ctag.spkv_keys += 1

//*****************************************************************************
// UID.inContainer( containerUid )
//*****************************************************************************
//retorna 1 se UID estiver no container containerUid
[FUNCTION inContainer]
REF1=<argv0>
//ignora se chegar em um char/player
if (<uid> < 040000000)
    return 0
//ok, achou    
elif (<cont>==<ref1>)
    return 1
//nao eh mas tem mais container pra procurar
elif (<cont>)
    return <cont.inContainer <ref1>>
//acabou, nao achou
else
    return 0
endif


[EOF]
